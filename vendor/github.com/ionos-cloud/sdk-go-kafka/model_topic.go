/*
 * Kafka as a Service API
 *
 * An managed Apache Kafka cluster is designed to be highly fault-tolerant and scalable, allowing large volumes of data to be ingested, stored, and processed in real-time. By distributing data across multiple brokers, Kafka achieves high throughput and low latency, making it suitable for applications requiring real-time data processing and analytics.
 *
 * API version: 1.7.1
 * Contact: support@cloud.ionos.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ionoscloud

import (
	"encoding/json"
)

// Topic A topic is a category or feed name to which records are published. Topics are the way Kafka organizes messages. They act as logical channels for data streams. Topics are split into partitions, making them scalable and allowing parallelism.
type Topic struct {
	// The name of the Kafka cluster topic. Must be 63 characters or less and must begin and end with an alphanumeric character (`[a-z0-9A-Z]`) with dashes (`-`), underscores (`_`), dots (`.`), and alphanumerics between.
	Name *string `json:"name"`
	// The number of replicas of the topic. The replication factor determines how many copies of the topic are stored on different brokers. The replication factor must be less than or equal to the number of brokers in the Kafka cluster.
	ReplicationFactor *int32 `json:"replicationFactor,omitempty"`
	// The number of partitions of the topic. Partitions allow for parallel processing of messages.
	NumberOfPartitions *int32             `json:"numberOfPartitions,omitempty"`
	LogRetention       *TopicLogRetention `json:"logRetention,omitempty"`
}

// NewTopic instantiates a new Topic object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewTopic(name string) *Topic {
	this := Topic{}

	this.Name = &name
	var replicationFactor int32 = 3
	this.ReplicationFactor = &replicationFactor
	var numberOfPartitions int32 = 3
	this.NumberOfPartitions = &numberOfPartitions

	return &this
}

// NewTopicWithDefaults instantiates a new Topic object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewTopicWithDefaults() *Topic {
	this := Topic{}
	var replicationFactor int32 = 3
	this.ReplicationFactor = &replicationFactor
	var numberOfPartitions int32 = 3
	this.NumberOfPartitions = &numberOfPartitions
	return &this
}

// GetName returns the Name field value
// If the value is explicit nil, the zero value for string will be returned
func (o *Topic) GetName() *string {
	if o == nil {
		return nil
	}

	return o.Name

}

// GetNameOk returns a tuple with the Name field value
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *Topic) GetNameOk() (*string, bool) {
	if o == nil {
		return nil, false
	}

	return o.Name, true
}

// SetName sets field value
func (o *Topic) SetName(v string) {

	o.Name = &v

}

// HasName returns a boolean if a field has been set.
func (o *Topic) HasName() bool {
	if o != nil && o.Name != nil {
		return true
	}

	return false
}

// GetReplicationFactor returns the ReplicationFactor field value
// If the value is explicit nil, the zero value for int32 will be returned
func (o *Topic) GetReplicationFactor() *int32 {
	if o == nil {
		return nil
	}

	return o.ReplicationFactor

}

// GetReplicationFactorOk returns a tuple with the ReplicationFactor field value
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *Topic) GetReplicationFactorOk() (*int32, bool) {
	if o == nil {
		return nil, false
	}

	return o.ReplicationFactor, true
}

// SetReplicationFactor sets field value
func (o *Topic) SetReplicationFactor(v int32) {

	o.ReplicationFactor = &v

}

// HasReplicationFactor returns a boolean if a field has been set.
func (o *Topic) HasReplicationFactor() bool {
	if o != nil && o.ReplicationFactor != nil {
		return true
	}

	return false
}

// GetNumberOfPartitions returns the NumberOfPartitions field value
// If the value is explicit nil, the zero value for int32 will be returned
func (o *Topic) GetNumberOfPartitions() *int32 {
	if o == nil {
		return nil
	}

	return o.NumberOfPartitions

}

// GetNumberOfPartitionsOk returns a tuple with the NumberOfPartitions field value
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *Topic) GetNumberOfPartitionsOk() (*int32, bool) {
	if o == nil {
		return nil, false
	}

	return o.NumberOfPartitions, true
}

// SetNumberOfPartitions sets field value
func (o *Topic) SetNumberOfPartitions(v int32) {

	o.NumberOfPartitions = &v

}

// HasNumberOfPartitions returns a boolean if a field has been set.
func (o *Topic) HasNumberOfPartitions() bool {
	if o != nil && o.NumberOfPartitions != nil {
		return true
	}

	return false
}

// GetLogRetention returns the LogRetention field value
// If the value is explicit nil, the zero value for TopicLogRetention will be returned
func (o *Topic) GetLogRetention() *TopicLogRetention {
	if o == nil {
		return nil
	}

	return o.LogRetention

}

// GetLogRetentionOk returns a tuple with the LogRetention field value
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *Topic) GetLogRetentionOk() (*TopicLogRetention, bool) {
	if o == nil {
		return nil, false
	}

	return o.LogRetention, true
}

// SetLogRetention sets field value
func (o *Topic) SetLogRetention(v TopicLogRetention) {

	o.LogRetention = &v

}

// HasLogRetention returns a boolean if a field has been set.
func (o *Topic) HasLogRetention() bool {
	if o != nil && o.LogRetention != nil {
		return true
	}

	return false
}

func (o Topic) MarshalJSON() ([]byte, error) {
	toSerialize := map[string]interface{}{}
	if o.Name != nil {
		toSerialize["name"] = o.Name
	}

	if o.ReplicationFactor != nil {
		toSerialize["replicationFactor"] = o.ReplicationFactor
	}

	if o.NumberOfPartitions != nil {
		toSerialize["numberOfPartitions"] = o.NumberOfPartitions
	}

	if o.LogRetention != nil {
		toSerialize["logRetention"] = o.LogRetention
	}

	return json.Marshal(toSerialize)
}

type NullableTopic struct {
	value *Topic
	isSet bool
}

func (v NullableTopic) Get() *Topic {
	return v.value
}

func (v *NullableTopic) Set(val *Topic) {
	v.value = val
	v.isSet = true
}

func (v NullableTopic) IsSet() bool {
	return v.isSet
}

func (v *NullableTopic) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableTopic(val *Topic) *NullableTopic {
	return &NullableTopic{value: val, isSet: true}
}

func (v NullableTopic) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableTopic) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
