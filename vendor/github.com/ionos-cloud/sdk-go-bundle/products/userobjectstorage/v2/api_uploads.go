/*
 * IONOS Object Storage API for user-owned buckets
 *
 * ## Overview The IONOS Object Storage API for user-owned buckets is a REST-based API that allows developers and applications to interact directly with IONOS' scalable storage solution, leveraging the S3 protocol for object storage operations. Its design ensures seamless compatibility with existing tools and libraries tailored for S3 systems.  ### API References - [Object Storage Management API Reference](https://api.ionos.com/docs/s3-management/v1/) for managing Access Keys - [Object Storage API Reference for contract-owned buckets](https://api.ionos.com/docs/s3-contract-owned-buckets/v2/) - Object Storage API Reference for user-owned buckets - current document  ### User documentation [IONOS Object Storage User Guide](https://docs.ionos.com/cloud/storage-and-backup/ionos-object-storage) * [Documentation on user-owned and contract-owned buckets](https://docs.ionos.com/cloud/managed-services/s3-object-storage/concepts/buckets) * [Documentation on S3 API Compatibility](https://docs.ionos.com/cloud/managed-services/s3-object-storage/concepts/s3-api-compatibility) * [S3 Tools](https://docs.ionos.com/cloud/managed-services/s3-object-storage/s3-tools)  ## Endpoints for user-owned buckets | Location | Region Name | Bucket Type | Endpoint | | --- | --- | --- | --- | | **Frankfurt, Germany** | **de** | User-owned | `https://s3.eu-central-1.ionoscloud.com`, <br/><br/>**s3 legacy endpoint:** `https://s3-de-central.profitbricks.com`  | | **Berlin, Germany** | **eu-central-2** | User-owned | `https://s3.eu-central-2.ionoscloud.com` | | **Logroño, Spain** | **eu-south-2** | User-owned | `https://s3.eu-south-2.ionoscloud.com` |  ## Changelog - **30.05.2024** Renaming to Storage Object API for user-owned buckets - **25.09.2023** Storage object operation names are now used for headlines. - **20.09.2023** Improved description for [HeadBucket](#tag/Basic-Operations/operation/HeadBucket) and [GetBucketLocation](#tag/Location/operation/GetBucketLocation). - **13.09.2023** Improved description for [Bucket Policy-related operations](#tag/Policy/operation/PutBucketPolicy). - **06.09.2023** Improved description for [Bucket ACL-related operations](#tag/ACL/operation/GetBucketAcl). - **30.08.2023** Improved description for [Object Lock-related operations](#tag/Object-Lock/operation/GetObjectLockConfiguration). - **24.07.2023** Improved description for [ListObjectsV2](#tag/Basic-Operations/operation/ListObjectsV2). - **17.07.2023** Improved description for [ListBuckets](#tag/Basic-Operations/operation/ListBuckets). - **07.07.2023** Improved description for [PutBucketReplication](#tag/Replication/operation/PutBucketReplication),   [GetBucketReplication](#tag/Replication/operation/GetBucketReplication), [DeleteBucketReplication](#tag/Replication/operation/DeleteBucketReplication). - **05.07.2023** Improved description for [PutBucketVersioning](#tag/Versioning/operation/PutBucketVersioning)   and [GetBucketVersioning](#tag/Versioning/operation/GetBucketVersioning). - **29.06.2023** Improved description for [PutBucketLifecycleConfiguration](#tag/Lifecycle/operation/PutBucketLifecycle). - **19.04.2023** Improved description on how to use the encryption with IONOS Object Storage managed (SSE-S3) and customer managed keys (SSE-C)   for [PutBucketEncryption](#tag/Encryption/operation/PutBucketEncryption) and [PutObject](#tag/Basic-Operations/operation/PutObject).
 *
 * API version: 2.0.15
 * Contact: support@cloud.ionos.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package userobjectstorage

import (
	_context "context"
	"fmt"
	"github.com/ionos-cloud/sdk-go-bundle/shared"
	"io"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"time"
)

// Linger please
var (
	_ _context.Context
)

// UploadsApiService UploadsApi service
type UploadsApiService service

type ApiAbortMultipartUploadRequest struct {
	ctx        _context.Context
	ApiService *UploadsApiService
	bucket     string
	key        string
	uploadId   *string
}

func (r ApiAbortMultipartUploadRequest) UploadId(uploadId string) ApiAbortMultipartUploadRequest {
	r.uploadId = &uploadId
	return r
}

func (r ApiAbortMultipartUploadRequest) Execute() (map[string]interface{}, *shared.APIResponse, error) {
	return r.ApiService.AbortMultipartUploadExecute(r)
}

/*
 * AbortMultipartUpload AbortMultipartUpload
 * <p>This operation aborts a multipart upload. After a multipart upload is aborted, no additional parts can be uploaded using that upload ID. The storage consumed by any previously uploaded parts will be freed. However, if any part uploads are currently in progress, those part uploads might or might not succeed. As a result, it might be necessary to abort a given multipart upload multiple times in order to completely free all storage consumed by all parts. </p>
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param bucket
 * @param key Key of the object for which the multipart upload was initiated. <p> **Possible values:** length ≥ 1 </p>
 * @return ApiAbortMultipartUploadRequest
 */
func (a *UploadsApiService) AbortMultipartUpload(ctx _context.Context, bucket string, key string) ApiAbortMultipartUploadRequest {
	return ApiAbortMultipartUploadRequest{
		ApiService: a,
		ctx:        ctx,
		bucket:     bucket,
		key:        key,
	}
}

/*
 * Execute executes the request
 * @return map[string]interface{}
 */
func (a *UploadsApiService) AbortMultipartUploadExecute(r ApiAbortMultipartUploadRequest) (map[string]interface{}, *shared.APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UploadsApiService.AbortMultipartUpload")
	if err != nil {
		gerr := shared.GenericOpenAPIError{}
		gerr.SetError(err.Error())
		return localVarReturnValue, nil, gerr
	}

	localVarPath := localBasePath + "/{Bucket}/{Key}?uploadId"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", _neturl.PathEscape(parameterValueToString(r.bucket, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Key"+"}", _neturl.PathEscape(parameterValueToString(r.key, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if shared.Strlen(r.bucket) < 3 {
		return localVarReturnValue, nil, reportError("bucket must have at least 3 elements")
	}
	if shared.Strlen(r.bucket) > 63 {
		return localVarReturnValue, nil, reportError("bucket must have less than 63 elements")
	}
	if shared.Strlen(r.key) < 1 {
		return localVarReturnValue, nil, reportError("key must have at least 1 elements")
	}
	if r.uploadId == nil {
		return localVarReturnValue, nil, reportError("uploadId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "uploadId", r.uploadId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/xml", "aplication/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(shared.ContextAPIKeys).(map[string]shared.APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, httpRequestTime, err := a.client.callAPI(req)

	localVarAPIResponse := &shared.APIResponse{
		Response:    localVarHTTPResponse,
		Method:      localVarHTTPMethod,
		RequestTime: httpRequestTime,
		RequestURL:  localVarPath,
		Operation:   "AbortMultipartUpload",
	}

	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := shared.GenericOpenAPIError{}
		newErr.SetStatusCode(localVarHTTPResponse.StatusCode)
		newErr.SetBody(localVarBody)
		newErr.SetError(fmt.Sprintf("%s: %s", localVarHTTPResponse.Status, string(localVarBody)))
		if localVarHTTPResponse.StatusCode == 480 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.SetError(err.Error())
				return localVarReturnValue, localVarAPIResponse, newErr
			}
			newErr.SetModel(v)
		}
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := shared.GenericOpenAPIError{}
		newErr.SetStatusCode(localVarHTTPResponse.StatusCode)
		newErr.SetBody(localVarBody)
		newErr.SetError(err.Error())
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

type ApiCompleteMultipartUploadRequest struct {
	ctx        _context.Context
	ApiService *UploadsApiService
	bucket     string
	key        string
	uploadId   *string
	example    *Example
}

func (r ApiCompleteMultipartUploadRequest) UploadId(uploadId string) ApiCompleteMultipartUploadRequest {
	r.uploadId = &uploadId
	return r
}
func (r ApiCompleteMultipartUploadRequest) Example(example Example) ApiCompleteMultipartUploadRequest {
	r.example = &example
	return r
}

func (r ApiCompleteMultipartUploadRequest) Execute() (CompleteMultipartUploadOutput, *shared.APIResponse, error) {
	return r.ApiService.CompleteMultipartUploadExecute(r)
}

/*
 * CompleteMultipartUpload CompleteMultipartUpload
 * <p>Completes a multipart upload by assembling previously uploaded parts.</p>          <p>After successfully uploading all relevant parts of an upload, you call this operation to complete the upload. When IONOS Object Storage  receives this request,  it concatenates all the parts in ascending  order by part number to create a new object. The parts  list must be included in the Complete Multipart Upload request. You must ensure that the parts list is complete. This operation concatenates the parts that you provide in the list. For each part in the list, you must provide the part number and the `ETag` value, returned after that part was uploaded.</p> <p>A Complete Multipart Upload request could take several minutes to process.  After IONOS Object Storage begins processing the request, it sends  an HTTP response header indicating a 200 OK response. While processing is  in progress, IONOS Object Storage sends white space characters  on a regular basis to keep the connection from timing out. Because a request  may fail after receiving the initial 200 OK response, it is advisable to  check the response body to establish whether the request was successful.</p>  <p> `CompleteMultipartUpload` has the following special errors:</p> <ul> <li> <p>Error code: `EntityTooSmall` </p> <ul> <li> <p>Description: Your proposed upload is smaller than the minimum allowed object size. Each part must be at least 5 MB in size, except the last part.</p> </li> <li> <p>400 Bad Request</p> </li> </ul> </li> <li> <p>Error code: `InvalidPart` </p> <ul> <li> <p>Description: One or more of the specified parts could not be found. The part might not have been uploaded, or the specified entity tag might not have matched the part's entity tag.</p> </li> <li> <p>400 Bad Request</p> </li> </ul> </li> <li> <p>Error code: `InvalidPartOrder` </p> <ul> <li> <p>Description: The list of parts was not in ascending order. The parts list must be specified in order by part number.</p> </li> <li> <p>400 Bad Request</p> </li> </ul> </li> <li> <p>Error code: `NoSuchUpload` </p> <ul> <li> <p>Description: The specified multipart upload does not exist. The upload ID might be invalid, or the multipart upload might have been aborted or completed.</p> </li> <li> <p>404 Not Found</p> </li> </ul> </li> </ul>
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param bucket
 * @param key Object key for which the multipart upload was initiated.
 * @return ApiCompleteMultipartUploadRequest
 */
func (a *UploadsApiService) CompleteMultipartUpload(ctx _context.Context, bucket string, key string) ApiCompleteMultipartUploadRequest {
	return ApiCompleteMultipartUploadRequest{
		ApiService: a,
		ctx:        ctx,
		bucket:     bucket,
		key:        key,
	}
}

/*
 * Execute executes the request
 * @return CompleteMultipartUploadOutput
 */
func (a *UploadsApiService) CompleteMultipartUploadExecute(r ApiCompleteMultipartUploadRequest) (CompleteMultipartUploadOutput, *shared.APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CompleteMultipartUploadOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UploadsApiService.CompleteMultipartUpload")
	if err != nil {
		gerr := shared.GenericOpenAPIError{}
		gerr.SetError(err.Error())
		return localVarReturnValue, nil, gerr
	}

	localVarPath := localBasePath + "/{Bucket}/{Key}?uploadId"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", _neturl.PathEscape(parameterValueToString(r.bucket, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Key"+"}", _neturl.PathEscape(parameterValueToString(r.key, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if shared.Strlen(r.bucket) < 3 {
		return localVarReturnValue, nil, reportError("bucket must have at least 3 elements")
	}
	if shared.Strlen(r.bucket) > 63 {
		return localVarReturnValue, nil, reportError("bucket must have less than 63 elements")
	}
	if shared.Strlen(r.key) < 1 {
		return localVarReturnValue, nil, reportError("key must have at least 1 elements")
	}
	if r.uploadId == nil {
		return localVarReturnValue, nil, reportError("uploadId is required and must be specified")
	}
	if r.example == nil {
		return localVarReturnValue, nil, reportError("example is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "uploadId", r.uploadId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.example
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(shared.ContextAPIKeys).(map[string]shared.APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, httpRequestTime, err := a.client.callAPI(req)

	localVarAPIResponse := &shared.APIResponse{
		Response:    localVarHTTPResponse,
		Method:      localVarHTTPMethod,
		RequestTime: httpRequestTime,
		RequestURL:  localVarPath,
		Operation:   "CompleteMultipartUpload",
	}

	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := shared.GenericOpenAPIError{}
		newErr.SetStatusCode(localVarHTTPResponse.StatusCode)
		newErr.SetBody(localVarBody)
		newErr.SetError(fmt.Sprintf("%s: %s", localVarHTTPResponse.Status, string(localVarBody)))
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := shared.GenericOpenAPIError{}
		newErr.SetStatusCode(localVarHTTPResponse.StatusCode)
		newErr.SetBody(localVarBody)
		newErr.SetError(err.Error())
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

type ApiCreateMultipartUploadRequest struct {
	ctx                                       _context.Context
	ApiService                                *UploadsApiService
	bucket                                    string
	key                                       string
	uploads                                   *bool
	cacheControl                              *string
	contentDisposition                        *string
	contentEncoding                           *string
	contentType                               *string
	expires                                   *time.Time
	xAmzServerSideEncryption                  *string
	xAmzStorageClass                          *string
	xAmzWebsiteRedirectLocation               *string
	xAmzServerSideEncryptionCustomerAlgorithm *string
	xAmzServerSideEncryptionCustomerKey       *string
	xAmzServerSideEncryptionCustomerKeyMD5    *string
	xAmzObjectLockMode                        *string
	xAmzObjectLockRetainUntilDate             *time.Time
	xAmzObjectLockLegalHold                   *string
	xAmzMeta                                  *string
}

func (r ApiCreateMultipartUploadRequest) Uploads(uploads bool) ApiCreateMultipartUploadRequest {
	r.uploads = &uploads
	return r
}
func (r ApiCreateMultipartUploadRequest) CacheControl(cacheControl string) ApiCreateMultipartUploadRequest {
	r.cacheControl = &cacheControl
	return r
}
func (r ApiCreateMultipartUploadRequest) ContentDisposition(contentDisposition string) ApiCreateMultipartUploadRequest {
	r.contentDisposition = &contentDisposition
	return r
}
func (r ApiCreateMultipartUploadRequest) ContentEncoding(contentEncoding string) ApiCreateMultipartUploadRequest {
	r.contentEncoding = &contentEncoding
	return r
}
func (r ApiCreateMultipartUploadRequest) ContentType(contentType string) ApiCreateMultipartUploadRequest {
	r.contentType = &contentType
	return r
}
func (r ApiCreateMultipartUploadRequest) Expires(expires time.Time) ApiCreateMultipartUploadRequest {
	r.expires = &expires
	return r
}
func (r ApiCreateMultipartUploadRequest) XAmzServerSideEncryption(xAmzServerSideEncryption string) ApiCreateMultipartUploadRequest {
	r.xAmzServerSideEncryption = &xAmzServerSideEncryption
	return r
}
func (r ApiCreateMultipartUploadRequest) XAmzStorageClass(xAmzStorageClass string) ApiCreateMultipartUploadRequest {
	r.xAmzStorageClass = &xAmzStorageClass
	return r
}
func (r ApiCreateMultipartUploadRequest) XAmzWebsiteRedirectLocation(xAmzWebsiteRedirectLocation string) ApiCreateMultipartUploadRequest {
	r.xAmzWebsiteRedirectLocation = &xAmzWebsiteRedirectLocation
	return r
}
func (r ApiCreateMultipartUploadRequest) XAmzServerSideEncryptionCustomerAlgorithm(xAmzServerSideEncryptionCustomerAlgorithm string) ApiCreateMultipartUploadRequest {
	r.xAmzServerSideEncryptionCustomerAlgorithm = &xAmzServerSideEncryptionCustomerAlgorithm
	return r
}
func (r ApiCreateMultipartUploadRequest) XAmzServerSideEncryptionCustomerKey(xAmzServerSideEncryptionCustomerKey string) ApiCreateMultipartUploadRequest {
	r.xAmzServerSideEncryptionCustomerKey = &xAmzServerSideEncryptionCustomerKey
	return r
}
func (r ApiCreateMultipartUploadRequest) XAmzServerSideEncryptionCustomerKeyMD5(xAmzServerSideEncryptionCustomerKeyMD5 string) ApiCreateMultipartUploadRequest {
	r.xAmzServerSideEncryptionCustomerKeyMD5 = &xAmzServerSideEncryptionCustomerKeyMD5
	return r
}
func (r ApiCreateMultipartUploadRequest) XAmzObjectLockMode(xAmzObjectLockMode string) ApiCreateMultipartUploadRequest {
	r.xAmzObjectLockMode = &xAmzObjectLockMode
	return r
}
func (r ApiCreateMultipartUploadRequest) XAmzObjectLockRetainUntilDate(xAmzObjectLockRetainUntilDate time.Time) ApiCreateMultipartUploadRequest {
	r.xAmzObjectLockRetainUntilDate = &xAmzObjectLockRetainUntilDate
	return r
}
func (r ApiCreateMultipartUploadRequest) XAmzObjectLockLegalHold(xAmzObjectLockLegalHold string) ApiCreateMultipartUploadRequest {
	r.xAmzObjectLockLegalHold = &xAmzObjectLockLegalHold
	return r
}
func (r ApiCreateMultipartUploadRequest) XAmzMeta(xAmzMeta string) ApiCreateMultipartUploadRequest {
	r.xAmzMeta = &xAmzMeta
	return r
}

func (r ApiCreateMultipartUploadRequest) Execute() (CreateMultipartUploadOutput, *shared.APIResponse, error) {
	return r.ApiService.CreateMultipartUploadExecute(r)
}

/*
 * CreateMultipartUpload CreateMultipartUpload
 * <p>This operation initiates a multipart upload and returns an upload ID. This upload ID is used to associate all of the parts in the specific multipart upload. You specify this upload ID in each of your subsequent upload part requests. You also include this upload ID in the final request to either complete or abort the multipart upload request.</p>
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param bucket
 * @param key Object key for which the multipart upload is to be initiated.
 * @return ApiCreateMultipartUploadRequest
 */
func (a *UploadsApiService) CreateMultipartUpload(ctx _context.Context, bucket string, key string) ApiCreateMultipartUploadRequest {
	return ApiCreateMultipartUploadRequest{
		ApiService: a,
		ctx:        ctx,
		bucket:     bucket,
		key:        key,
	}
}

/*
 * Execute executes the request
 * @return CreateMultipartUploadOutput
 */
func (a *UploadsApiService) CreateMultipartUploadExecute(r ApiCreateMultipartUploadRequest) (CreateMultipartUploadOutput, *shared.APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CreateMultipartUploadOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UploadsApiService.CreateMultipartUpload")
	if err != nil {
		gerr := shared.GenericOpenAPIError{}
		gerr.SetError(err.Error())
		return localVarReturnValue, nil, gerr
	}

	localVarPath := localBasePath + "/{Bucket}/{Key}?uploads"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", _neturl.PathEscape(parameterValueToString(r.bucket, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Key"+"}", _neturl.PathEscape(parameterValueToString(r.key, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if shared.Strlen(r.bucket) < 3 {
		return localVarReturnValue, nil, reportError("bucket must have at least 3 elements")
	}
	if shared.Strlen(r.bucket) > 63 {
		return localVarReturnValue, nil, reportError("bucket must have less than 63 elements")
	}
	if shared.Strlen(r.key) < 1 {
		return localVarReturnValue, nil, reportError("key must have at least 1 elements")
	}
	if r.uploads == nil {
		return localVarReturnValue, nil, reportError("uploads is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "uploads", r.uploads, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.cacheControl != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Cache-Control", r.cacheControl, "")
	}
	if r.contentDisposition != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Disposition", r.contentDisposition, "")
	}
	if r.contentEncoding != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Encoding", r.contentEncoding, "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
	}
	if r.expires != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Expires", r.expires, "")
	}
	if r.xAmzServerSideEncryption != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption", r.xAmzServerSideEncryption, "")
	}
	if r.xAmzStorageClass != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-storage-class", r.xAmzStorageClass, "")
	}
	if r.xAmzWebsiteRedirectLocation != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-website-redirect-location", r.xAmzWebsiteRedirectLocation, "")
	}
	if r.xAmzServerSideEncryptionCustomerAlgorithm != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-customer-algorithm", r.xAmzServerSideEncryptionCustomerAlgorithm, "")
	}
	if r.xAmzServerSideEncryptionCustomerKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-customer-key", r.xAmzServerSideEncryptionCustomerKey, "")
	}
	if r.xAmzServerSideEncryptionCustomerKeyMD5 != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-customer-key-MD5", r.xAmzServerSideEncryptionCustomerKeyMD5, "")
	}
	if r.xAmzObjectLockMode != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-object-lock-mode", r.xAmzObjectLockMode, "")
	}
	if r.xAmzObjectLockRetainUntilDate != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-object-lock-retain-until-date", r.xAmzObjectLockRetainUntilDate, "")
	}
	if r.xAmzObjectLockLegalHold != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-object-lock-legal-hold", r.xAmzObjectLockLegalHold, "")
	}
	if r.xAmzMeta != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-meta-", r.xAmzMeta, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(shared.ContextAPIKeys).(map[string]shared.APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, httpRequestTime, err := a.client.callAPI(req)

	localVarAPIResponse := &shared.APIResponse{
		Response:    localVarHTTPResponse,
		Method:      localVarHTTPMethod,
		RequestTime: httpRequestTime,
		RequestURL:  localVarPath,
		Operation:   "CreateMultipartUpload",
	}

	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := shared.GenericOpenAPIError{}
		newErr.SetStatusCode(localVarHTTPResponse.StatusCode)
		newErr.SetBody(localVarBody)
		newErr.SetError(fmt.Sprintf("%s: %s", localVarHTTPResponse.Status, string(localVarBody)))
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := shared.GenericOpenAPIError{}
		newErr.SetStatusCode(localVarHTTPResponse.StatusCode)
		newErr.SetBody(localVarBody)
		newErr.SetError(err.Error())
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

type ApiListMultipartUploadsRequest struct {
	ctx             _context.Context
	ApiService      *UploadsApiService
	bucket          string
	uploads         *bool
	delimiter       *string
	encodingType    *string
	keyMarker       *string
	maxUploads      *int32
	prefix          *string
	uploadIdMarker  *string
	maxUploads2     *string
	keyMarker2      *string
	uploadIdMarker2 *string
}

func (r ApiListMultipartUploadsRequest) Uploads(uploads bool) ApiListMultipartUploadsRequest {
	r.uploads = &uploads
	return r
}
func (r ApiListMultipartUploadsRequest) Delimiter(delimiter string) ApiListMultipartUploadsRequest {
	r.delimiter = &delimiter
	return r
}
func (r ApiListMultipartUploadsRequest) EncodingType(encodingType string) ApiListMultipartUploadsRequest {
	r.encodingType = &encodingType
	return r
}
func (r ApiListMultipartUploadsRequest) KeyMarker(keyMarker string) ApiListMultipartUploadsRequest {
	r.keyMarker = &keyMarker
	return r
}
func (r ApiListMultipartUploadsRequest) MaxUploads(maxUploads int32) ApiListMultipartUploadsRequest {
	r.maxUploads = &maxUploads
	return r
}
func (r ApiListMultipartUploadsRequest) Prefix(prefix string) ApiListMultipartUploadsRequest {
	r.prefix = &prefix
	return r
}
func (r ApiListMultipartUploadsRequest) UploadIdMarker(uploadIdMarker string) ApiListMultipartUploadsRequest {
	r.uploadIdMarker = &uploadIdMarker
	return r
}
func (r ApiListMultipartUploadsRequest) MaxUploads2(maxUploads2 string) ApiListMultipartUploadsRequest {
	r.maxUploads2 = &maxUploads2
	return r
}
func (r ApiListMultipartUploadsRequest) KeyMarker2(keyMarker2 string) ApiListMultipartUploadsRequest {
	r.keyMarker2 = &keyMarker2
	return r
}
func (r ApiListMultipartUploadsRequest) UploadIdMarker2(uploadIdMarker2 string) ApiListMultipartUploadsRequest {
	r.uploadIdMarker2 = &uploadIdMarker2
	return r
}

func (r ApiListMultipartUploadsRequest) Execute() (ListMultipartUploadsOutput, *shared.APIResponse, error) {
	return r.ApiService.ListMultipartUploadsExecute(r)
}

/*
 * ListMultipartUploads ListMultipartUploads
 * <p>This operation lists in-progress multipart uploads. An in-progress multipart upload is a multipart upload that has been initiated using the Initiate Multipart Upload request, but has not yet been completed or aborted.</p> <p>This operation returns at most 1,000 multipart uploads in the response. 1,000 multipart uploads is the maximum number of uploads a response can include, which is also the default value. You can further limit the number of uploads in a response by specifying the `max-uploads` parameter in the response. If additional multipart uploads satisfy the list criteria, the response will contain an `IsTruncated` element with the value true. To list the additional multipart uploads, use the `key-marker` and `upload-id-marker` request parameters.</p> <p>In the response, the uploads are sorted by key. If your application has initiated more than one multipart upload using the same object key, then uploads in the response are first sorted by key. Additionally, uploads are sorted in ascending order within each key by the upload initiation time.</p>
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param bucket
 * @return ApiListMultipartUploadsRequest
 */
func (a *UploadsApiService) ListMultipartUploads(ctx _context.Context, bucket string) ApiListMultipartUploadsRequest {
	return ApiListMultipartUploadsRequest{
		ApiService: a,
		ctx:        ctx,
		bucket:     bucket,
	}
}

/*
 * Execute executes the request
 * @return ListMultipartUploadsOutput
 */
func (a *UploadsApiService) ListMultipartUploadsExecute(r ApiListMultipartUploadsRequest) (ListMultipartUploadsOutput, *shared.APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ListMultipartUploadsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UploadsApiService.ListMultipartUploads")
	if err != nil {
		gerr := shared.GenericOpenAPIError{}
		gerr.SetError(err.Error())
		return localVarReturnValue, nil, gerr
	}

	localVarPath := localBasePath + "/{Bucket}?uploads"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", _neturl.PathEscape(parameterValueToString(r.bucket, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if shared.Strlen(r.bucket) < 3 {
		return localVarReturnValue, nil, reportError("bucket must have at least 3 elements")
	}
	if shared.Strlen(r.bucket) > 63 {
		return localVarReturnValue, nil, reportError("bucket must have less than 63 elements")
	}
	if r.uploads == nil {
		return localVarReturnValue, nil, reportError("uploads is required and must be specified")
	}

	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "")
	}
	if r.encodingType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "encoding-type", r.encodingType, "")
	}
	if r.keyMarker != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key-marker", r.keyMarker, "")
	}
	if r.maxUploads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-uploads", r.maxUploads, "")
	}
	if r.prefix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", r.prefix, "")
	}
	if r.uploadIdMarker != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "upload-id-marker", r.uploadIdMarker, "")
	}
	if r.maxUploads2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxUploads", r.maxUploads2, "")
	}
	if r.keyMarker2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeyMarker", r.keyMarker2, "")
	}
	if r.uploadIdMarker2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UploadIdMarker", r.uploadIdMarker2, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "uploads", r.uploads, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(shared.ContextAPIKeys).(map[string]shared.APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, httpRequestTime, err := a.client.callAPI(req)

	localVarAPIResponse := &shared.APIResponse{
		Response:    localVarHTTPResponse,
		Method:      localVarHTTPMethod,
		RequestTime: httpRequestTime,
		RequestURL:  localVarPath,
		Operation:   "ListMultipartUploads",
	}

	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := shared.GenericOpenAPIError{}
		newErr.SetStatusCode(localVarHTTPResponse.StatusCode)
		newErr.SetBody(localVarBody)
		newErr.SetError(fmt.Sprintf("%s: %s", localVarHTTPResponse.Status, string(localVarBody)))
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := shared.GenericOpenAPIError{}
		newErr.SetStatusCode(localVarHTTPResponse.StatusCode)
		newErr.SetBody(localVarBody)
		newErr.SetError(err.Error())
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

type ApiListPartsRequest struct {
	ctx               _context.Context
	ApiService        *UploadsApiService
	bucket            string
	key               string
	uploadId          *string
	maxParts          *int32
	partNumberMarker  *int32
	partNumberMarker2 *string
}

func (r ApiListPartsRequest) UploadId(uploadId string) ApiListPartsRequest {
	r.uploadId = &uploadId
	return r
}
func (r ApiListPartsRequest) MaxParts(maxParts int32) ApiListPartsRequest {
	r.maxParts = &maxParts
	return r
}
func (r ApiListPartsRequest) PartNumberMarker(partNumberMarker int32) ApiListPartsRequest {
	r.partNumberMarker = &partNumberMarker
	return r
}
func (r ApiListPartsRequest) PartNumberMarker2(partNumberMarker2 string) ApiListPartsRequest {
	r.partNumberMarker2 = &partNumberMarker2
	return r
}

func (r ApiListPartsRequest) Execute() (ListPartsOutput, *shared.APIResponse, error) {
	return r.ApiService.ListPartsExecute(r)
}

/*
 * ListParts ListParts
 * <p>Lists the parts that have been uploaded for a specific multipart upload. This operation must include the upload ID, which you obtain by sending the initiate multipart upload request. This request returns a maximum of 1,000 uploaded parts. The default number of parts returned is 1,000 parts. You can restrict the number of parts returned by specifying the `max-parts` request parameter. If your multipart upload consists of more than 1,000 parts, the response returns an `IsTruncated` field with the value of true, and a `NextPartNumberMarker` element. In subsequent `ListParts` requests you can include the part-number-marker query string parameter and set its value to the `NextPartNumberMarker` field value from the previous response.</p>
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param bucket
 * @param key Object key for which the multipart upload was initiated.
 * @return ApiListPartsRequest
 */
func (a *UploadsApiService) ListParts(ctx _context.Context, bucket string, key string) ApiListPartsRequest {
	return ApiListPartsRequest{
		ApiService: a,
		ctx:        ctx,
		bucket:     bucket,
		key:        key,
	}
}

/*
 * Execute executes the request
 * @return ListPartsOutput
 */
func (a *UploadsApiService) ListPartsExecute(r ApiListPartsRequest) (ListPartsOutput, *shared.APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ListPartsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UploadsApiService.ListParts")
	if err != nil {
		gerr := shared.GenericOpenAPIError{}
		gerr.SetError(err.Error())
		return localVarReturnValue, nil, gerr
	}

	localVarPath := localBasePath + "/{Bucket}/{Key}?uploadId"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", _neturl.PathEscape(parameterValueToString(r.bucket, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Key"+"}", _neturl.PathEscape(parameterValueToString(r.key, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if shared.Strlen(r.bucket) < 3 {
		return localVarReturnValue, nil, reportError("bucket must have at least 3 elements")
	}
	if shared.Strlen(r.bucket) > 63 {
		return localVarReturnValue, nil, reportError("bucket must have less than 63 elements")
	}
	if shared.Strlen(r.key) < 1 {
		return localVarReturnValue, nil, reportError("key must have at least 1 elements")
	}
	if r.uploadId == nil {
		return localVarReturnValue, nil, reportError("uploadId is required and must be specified")
	}

	if r.maxParts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-parts", r.maxParts, "")
	}
	if r.partNumberMarker != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "part-number-marker", r.partNumberMarker, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "uploadId", r.uploadId, "")
	if r.partNumberMarker2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PartNumberMarker", r.partNumberMarker2, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(shared.ContextAPIKeys).(map[string]shared.APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, httpRequestTime, err := a.client.callAPI(req)

	localVarAPIResponse := &shared.APIResponse{
		Response:    localVarHTTPResponse,
		Method:      localVarHTTPMethod,
		RequestTime: httpRequestTime,
		RequestURL:  localVarPath,
		Operation:   "ListParts",
	}

	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := shared.GenericOpenAPIError{}
		newErr.SetStatusCode(localVarHTTPResponse.StatusCode)
		newErr.SetBody(localVarBody)
		newErr.SetError(fmt.Sprintf("%s: %s", localVarHTTPResponse.Status, string(localVarBody)))
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := shared.GenericOpenAPIError{}
		newErr.SetStatusCode(localVarHTTPResponse.StatusCode)
		newErr.SetBody(localVarBody)
		newErr.SetError(err.Error())
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

type ApiUploadPartRequest struct {
	ctx                                       _context.Context
	ApiService                                *UploadsApiService
	bucket                                    string
	key                                       string
	partNumber                                *int32
	uploadId                                  *string
	uploadPartRequest                         *UploadPartRequest
	contentLength                             *int32
	contentMD5                                *string
	xAmzServerSideEncryptionCustomerAlgorithm *string
	xAmzServerSideEncryptionCustomerKey       *string
	xAmzServerSideEncryptionCustomerKeyMD5    *string
}

func (r ApiUploadPartRequest) PartNumber(partNumber int32) ApiUploadPartRequest {
	r.partNumber = &partNumber
	return r
}
func (r ApiUploadPartRequest) UploadId(uploadId string) ApiUploadPartRequest {
	r.uploadId = &uploadId
	return r
}
func (r ApiUploadPartRequest) UploadPartRequest(uploadPartRequest UploadPartRequest) ApiUploadPartRequest {
	r.uploadPartRequest = &uploadPartRequest
	return r
}
func (r ApiUploadPartRequest) ContentLength(contentLength int32) ApiUploadPartRequest {
	r.contentLength = &contentLength
	return r
}
func (r ApiUploadPartRequest) ContentMD5(contentMD5 string) ApiUploadPartRequest {
	r.contentMD5 = &contentMD5
	return r
}
func (r ApiUploadPartRequest) XAmzServerSideEncryptionCustomerAlgorithm(xAmzServerSideEncryptionCustomerAlgorithm string) ApiUploadPartRequest {
	r.xAmzServerSideEncryptionCustomerAlgorithm = &xAmzServerSideEncryptionCustomerAlgorithm
	return r
}
func (r ApiUploadPartRequest) XAmzServerSideEncryptionCustomerKey(xAmzServerSideEncryptionCustomerKey string) ApiUploadPartRequest {
	r.xAmzServerSideEncryptionCustomerKey = &xAmzServerSideEncryptionCustomerKey
	return r
}
func (r ApiUploadPartRequest) XAmzServerSideEncryptionCustomerKeyMD5(xAmzServerSideEncryptionCustomerKeyMD5 string) ApiUploadPartRequest {
	r.xAmzServerSideEncryptionCustomerKeyMD5 = &xAmzServerSideEncryptionCustomerKeyMD5
	return r
}

func (r ApiUploadPartRequest) Execute() (map[string]interface{}, *shared.APIResponse, error) {
	return r.ApiService.UploadPartExecute(r)
}

/*
 * UploadPart UploadPart
 * <p>Uploads a part in a multipart upload.</p> <note> <p>In this operation, you provide part data in your request. However, you have an option to specify your existing IONOS Object Storage object as a data source for the part you are uploading. To upload a part from an existing object, you use the `UploadPartCopy` operation. </p> </note> <p>You must initiate a multipart upload (see `CreateMultipartUpload`) before you can upload any part. In response to your initiate request, IONOS Object Storage returns an upload ID, a unique identifier, that you must include in your upload part request.</p> <p>Part numbers can be any number from 1 to 10,000, inclusive. A part number uniquely identifies a part and also defines its position within the object being created. If you upload a new part using the same part number that was used with a previous part, the previously uploaded part is overwritten. Each part must be at least 5 MB in size, except the last part. There is no size limit on the last part of your multipart upload.</p> <p>To ensure that data is not corrupted when traversing the network, specify the `Content-MD5` header in the upload part request. IONOS Object Storage checks the part data against the provided MD5 value. If they do not match, IONOS Object Storage returns an error. </p> <p>If the upload request is signed with Signature Version 4, then IONOS Object Storage uses the `x-amz-content-sha256` header as a checksum instead of `Content-MD5`. </p> <p> <b>Note:</b> After you initiate multipart upload and upload one or more parts, you must either complete or abort multipart upload in order to stop getting charged for storage of the uploaded parts. Only after you either complete or abort multipart upload, IONOS Object Storage frees up the parts storage and stops charging you for the parts storage.</p>
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param bucket
 * @param key Object key for which the multipart upload was initiated.
 * @return ApiUploadPartRequest
 */
func (a *UploadsApiService) UploadPart(ctx _context.Context, bucket string, key string) ApiUploadPartRequest {
	return ApiUploadPartRequest{
		ApiService: a,
		ctx:        ctx,
		bucket:     bucket,
		key:        key,
	}
}

/*
 * Execute executes the request
 * @return map[string]interface{}
 */
func (a *UploadsApiService) UploadPartExecute(r ApiUploadPartRequest) (map[string]interface{}, *shared.APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UploadsApiService.UploadPart")
	if err != nil {
		gerr := shared.GenericOpenAPIError{}
		gerr.SetError(err.Error())
		return localVarReturnValue, nil, gerr
	}

	localVarPath := localBasePath + "/{Bucket}/{Key}?uploadId"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", _neturl.PathEscape(parameterValueToString(r.bucket, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Key"+"}", _neturl.PathEscape(parameterValueToString(r.key, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if shared.Strlen(r.bucket) < 3 {
		return localVarReturnValue, nil, reportError("bucket must have at least 3 elements")
	}
	if shared.Strlen(r.bucket) > 63 {
		return localVarReturnValue, nil, reportError("bucket must have less than 63 elements")
	}
	if shared.Strlen(r.key) < 1 {
		return localVarReturnValue, nil, reportError("key must have at least 1 elements")
	}
	if r.partNumber == nil {
		return localVarReturnValue, nil, reportError("partNumber is required and must be specified")
	}
	if r.uploadId == nil {
		return localVarReturnValue, nil, reportError("uploadId is required and must be specified")
	}
	if r.uploadPartRequest == nil {
		return localVarReturnValue, nil, reportError("uploadPartRequest is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "partNumber", r.partNumber, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "uploadId", r.uploadId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.contentLength != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Length", r.contentLength, "")
	}
	if r.contentMD5 != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-MD5", r.contentMD5, "")
	}
	if r.xAmzServerSideEncryptionCustomerAlgorithm != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-customer-algorithm", r.xAmzServerSideEncryptionCustomerAlgorithm, "")
	}
	if r.xAmzServerSideEncryptionCustomerKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-customer-key", r.xAmzServerSideEncryptionCustomerKey, "")
	}
	if r.xAmzServerSideEncryptionCustomerKeyMD5 != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-customer-key-MD5", r.xAmzServerSideEncryptionCustomerKeyMD5, "")
	}
	// body params
	localVarPostBody = r.uploadPartRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(shared.ContextAPIKeys).(map[string]shared.APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, httpRequestTime, err := a.client.callAPI(req)

	localVarAPIResponse := &shared.APIResponse{
		Response:    localVarHTTPResponse,
		Method:      localVarHTTPMethod,
		RequestTime: httpRequestTime,
		RequestURL:  localVarPath,
		Operation:   "UploadPart",
	}

	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := shared.GenericOpenAPIError{}
		newErr.SetStatusCode(localVarHTTPResponse.StatusCode)
		newErr.SetBody(localVarBody)
		newErr.SetError(fmt.Sprintf("%s: %s", localVarHTTPResponse.Status, string(localVarBody)))
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := shared.GenericOpenAPIError{}
		newErr.SetStatusCode(localVarHTTPResponse.StatusCode)
		newErr.SetBody(localVarBody)
		newErr.SetError(err.Error())
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

type ApiUploadPartCopyRequest struct {
	ctx                                       _context.Context
	ApiService                                *UploadsApiService
	bucket                                    string
	xAmzCopySource                            *string
	key                                       string
	partNumber                                *int32
	uploadId                                  *string
	xAmzCopySourceIfMatch                     *string
	xAmzCopySourceIfModifiedSince             *time.Time
	xAmzCopySourceIfNoneMatch                 *string
	xAmzCopySourceIfUnmodifiedSince           *time.Time
	xAmzCopySourceRange                       *string
	xAmzServerSideEncryptionCustomerAlgorithm *string
}

func (r ApiUploadPartCopyRequest) XAmzCopySource(xAmzCopySource string) ApiUploadPartCopyRequest {
	r.xAmzCopySource = &xAmzCopySource
	return r
}
func (r ApiUploadPartCopyRequest) PartNumber(partNumber int32) ApiUploadPartCopyRequest {
	r.partNumber = &partNumber
	return r
}
func (r ApiUploadPartCopyRequest) UploadId(uploadId string) ApiUploadPartCopyRequest {
	r.uploadId = &uploadId
	return r
}
func (r ApiUploadPartCopyRequest) XAmzCopySourceIfMatch(xAmzCopySourceIfMatch string) ApiUploadPartCopyRequest {
	r.xAmzCopySourceIfMatch = &xAmzCopySourceIfMatch
	return r
}
func (r ApiUploadPartCopyRequest) XAmzCopySourceIfModifiedSince(xAmzCopySourceIfModifiedSince time.Time) ApiUploadPartCopyRequest {
	r.xAmzCopySourceIfModifiedSince = &xAmzCopySourceIfModifiedSince
	return r
}
func (r ApiUploadPartCopyRequest) XAmzCopySourceIfNoneMatch(xAmzCopySourceIfNoneMatch string) ApiUploadPartCopyRequest {
	r.xAmzCopySourceIfNoneMatch = &xAmzCopySourceIfNoneMatch
	return r
}
func (r ApiUploadPartCopyRequest) XAmzCopySourceIfUnmodifiedSince(xAmzCopySourceIfUnmodifiedSince time.Time) ApiUploadPartCopyRequest {
	r.xAmzCopySourceIfUnmodifiedSince = &xAmzCopySourceIfUnmodifiedSince
	return r
}
func (r ApiUploadPartCopyRequest) XAmzCopySourceRange(xAmzCopySourceRange string) ApiUploadPartCopyRequest {
	r.xAmzCopySourceRange = &xAmzCopySourceRange
	return r
}
func (r ApiUploadPartCopyRequest) XAmzServerSideEncryptionCustomerAlgorithm(xAmzServerSideEncryptionCustomerAlgorithm string) ApiUploadPartCopyRequest {
	r.xAmzServerSideEncryptionCustomerAlgorithm = &xAmzServerSideEncryptionCustomerAlgorithm
	return r
}

func (r ApiUploadPartCopyRequest) Execute() (UploadPartCopyOutput, *shared.APIResponse, error) {
	return r.ApiService.UploadPartCopyExecute(r)
}

/*
 * UploadPartCopy UploadPartCopy
 * <p>Uploads a part by copying data from an existing object as data source. You specify the data source by adding the request header `x-amz-copy-source` in your request and a byte range by adding the request header `x-amz-copy-source-range` in your request. </p> <p>The minimum allowable part size for a multipart upload is 5 MB.</p> <note> <p>Instead of using an existing object as part data, you might use the `UploadPart` operation and provide data in your request.</p> </note> <p>You must initiate a multipart upload before you can upload any part. In response to your initiate request. IONOS Object Storage returns a unique identifier, the upload ID, that you must include in your upload part request.</p>
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param bucket
 * @param key Object key for which the multipart upload was initiated.
 * @return ApiUploadPartCopyRequest
 */
func (a *UploadsApiService) UploadPartCopy(ctx _context.Context, bucket string, key string) ApiUploadPartCopyRequest {
	return ApiUploadPartCopyRequest{
		ApiService: a,
		ctx:        ctx,
		bucket:     bucket,
		key:        key,
	}
}

/*
 * Execute executes the request
 * @return UploadPartCopyOutput
 */
func (a *UploadsApiService) UploadPartCopyExecute(r ApiUploadPartCopyRequest) (UploadPartCopyOutput, *shared.APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UploadPartCopyOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UploadsApiService.UploadPartCopy")
	if err != nil {
		gerr := shared.GenericOpenAPIError{}
		gerr.SetError(err.Error())
		return localVarReturnValue, nil, gerr
	}

	localVarPath := localBasePath + "/{Bucket}/{Key}?x-amz-copy-source&partNumber&uploadId"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", _neturl.PathEscape(parameterValueToString(r.bucket, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Key"+"}", _neturl.PathEscape(parameterValueToString(r.key, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if shared.Strlen(r.bucket) < 3 {
		return localVarReturnValue, nil, reportError("bucket must have at least 3 elements")
	}
	if shared.Strlen(r.bucket) > 63 {
		return localVarReturnValue, nil, reportError("bucket must have less than 63 elements")
	}
	if r.xAmzCopySource == nil {
		return localVarReturnValue, nil, reportError("xAmzCopySource is required and must be specified")
	}
	if shared.Strlen(r.key) < 1 {
		return localVarReturnValue, nil, reportError("key must have at least 1 elements")
	}
	if r.partNumber == nil {
		return localVarReturnValue, nil, reportError("partNumber is required and must be specified")
	}
	if r.uploadId == nil {
		return localVarReturnValue, nil, reportError("uploadId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "partNumber", r.partNumber, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "uploadId", r.uploadId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-copy-source", r.xAmzCopySource, "")
	if r.xAmzCopySourceIfMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-copy-source-if-match", r.xAmzCopySourceIfMatch, "")
	}
	if r.xAmzCopySourceIfModifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-copy-source-if-modified-since", r.xAmzCopySourceIfModifiedSince, "")
	}
	if r.xAmzCopySourceIfNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-copy-source-if-none-match", r.xAmzCopySourceIfNoneMatch, "")
	}
	if r.xAmzCopySourceIfUnmodifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-copy-source-if-unmodified-since", r.xAmzCopySourceIfUnmodifiedSince, "")
	}
	if r.xAmzCopySourceRange != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-copy-source-range", r.xAmzCopySourceRange, "")
	}
	if r.xAmzServerSideEncryptionCustomerAlgorithm != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-customer-algorithm", r.xAmzServerSideEncryptionCustomerAlgorithm, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(shared.ContextAPIKeys).(map[string]shared.APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, httpRequestTime, err := a.client.callAPI(req)

	localVarAPIResponse := &shared.APIResponse{
		Response:    localVarHTTPResponse,
		Method:      localVarHTTPMethod,
		RequestTime: httpRequestTime,
		RequestURL:  localVarPath,
		Operation:   "UploadPartCopy",
	}

	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := shared.GenericOpenAPIError{}
		newErr.SetStatusCode(localVarHTTPResponse.StatusCode)
		newErr.SetBody(localVarBody)
		newErr.SetError(fmt.Sprintf("%s: %s", localVarHTTPResponse.Status, string(localVarBody)))
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := shared.GenericOpenAPIError{}
		newErr.SetStatusCode(localVarHTTPResponse.StatusCode)
		newErr.SetBody(localVarBody)
		newErr.SetError(err.Error())
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}
