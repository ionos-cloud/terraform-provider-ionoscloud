/*
 * Kafka as a Service API
 *
 * An managed Apache Kafka cluster is designed to be highly fault-tolerant and scalable, allowing large volumes of data to be ingested, stored, and processed in real-time. By distributing data across multiple brokers, Kafka achieves high throughput and low latency, making it suitable for applications requiring real-time data processing and analytics.
 *
 * API version: 1.7.1
 * Contact: support@cloud.ionos.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package kafka

import (
	"encoding/json"
)

// checks if the Topic type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &Topic{}

// Topic A topic is a category or feed name to which records are published. Topics are the way Kafka organizes messages. They act as logical channels for data streams. Topics are split into partitions, making them scalable and allowing parallelism.
type Topic struct {
	// The name of the Kafka cluster topic. Must be 63 characters or less and must begin and end with an alphanumeric character (`[a-z0-9A-Z]`) with dashes (`-`), underscores (`_`), dots (`.`), and alphanumerics between.
	Name string `json:"name"`
	// The number of replicas of the topic. The replication factor determines how many copies of the topic are stored on different brokers. The replication factor must be less than or equal to the number of brokers in the Kafka cluster.
	ReplicationFactor *int32 `json:"replicationFactor,omitempty"`
	// The number of partitions of the topic. Partitions allow for parallel processing of messages.
	NumberOfPartitions *int32             `json:"numberOfPartitions,omitempty"`
	LogRetention       *TopicLogRetention `json:"logRetention,omitempty"`
}

// NewTopic instantiates a new Topic object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewTopic(name string) *Topic {
	this := Topic{}

	this.Name = name
	var replicationFactor int32 = 3
	this.ReplicationFactor = &replicationFactor
	var numberOfPartitions int32 = 3
	this.NumberOfPartitions = &numberOfPartitions

	return &this
}

// NewTopicWithDefaults instantiates a new Topic object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewTopicWithDefaults() *Topic {
	this := Topic{}
	var replicationFactor int32 = 3
	this.ReplicationFactor = &replicationFactor
	var numberOfPartitions int32 = 3
	this.NumberOfPartitions = &numberOfPartitions
	return &this
}

// GetName returns the Name field value
func (o *Topic) GetName() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Name
}

// GetNameOk returns a tuple with the Name field value
// and a boolean to check if the value has been set.
func (o *Topic) GetNameOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Name, true
}

// SetName sets field value
func (o *Topic) SetName(v string) {
	o.Name = v
}

// GetReplicationFactor returns the ReplicationFactor field value if set, zero value otherwise.
func (o *Topic) GetReplicationFactor() int32 {
	if o == nil || IsNil(o.ReplicationFactor) {
		var ret int32
		return ret
	}
	return *o.ReplicationFactor
}

// GetReplicationFactorOk returns a tuple with the ReplicationFactor field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Topic) GetReplicationFactorOk() (*int32, bool) {
	if o == nil || IsNil(o.ReplicationFactor) {
		return nil, false
	}
	return o.ReplicationFactor, true
}

// HasReplicationFactor returns a boolean if a field has been set.
func (o *Topic) HasReplicationFactor() bool {
	if o != nil && !IsNil(o.ReplicationFactor) {
		return true
	}

	return false
}

// SetReplicationFactor gets a reference to the given int32 and assigns it to the ReplicationFactor field.
func (o *Topic) SetReplicationFactor(v int32) {
	o.ReplicationFactor = &v
}

// GetNumberOfPartitions returns the NumberOfPartitions field value if set, zero value otherwise.
func (o *Topic) GetNumberOfPartitions() int32 {
	if o == nil || IsNil(o.NumberOfPartitions) {
		var ret int32
		return ret
	}
	return *o.NumberOfPartitions
}

// GetNumberOfPartitionsOk returns a tuple with the NumberOfPartitions field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Topic) GetNumberOfPartitionsOk() (*int32, bool) {
	if o == nil || IsNil(o.NumberOfPartitions) {
		return nil, false
	}
	return o.NumberOfPartitions, true
}

// HasNumberOfPartitions returns a boolean if a field has been set.
func (o *Topic) HasNumberOfPartitions() bool {
	if o != nil && !IsNil(o.NumberOfPartitions) {
		return true
	}

	return false
}

// SetNumberOfPartitions gets a reference to the given int32 and assigns it to the NumberOfPartitions field.
func (o *Topic) SetNumberOfPartitions(v int32) {
	o.NumberOfPartitions = &v
}

// GetLogRetention returns the LogRetention field value if set, zero value otherwise.
func (o *Topic) GetLogRetention() TopicLogRetention {
	if o == nil || IsNil(o.LogRetention) {
		var ret TopicLogRetention
		return ret
	}
	return *o.LogRetention
}

// GetLogRetentionOk returns a tuple with the LogRetention field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Topic) GetLogRetentionOk() (*TopicLogRetention, bool) {
	if o == nil || IsNil(o.LogRetention) {
		return nil, false
	}
	return o.LogRetention, true
}

// HasLogRetention returns a boolean if a field has been set.
func (o *Topic) HasLogRetention() bool {
	if o != nil && !IsNil(o.LogRetention) {
		return true
	}

	return false
}

// SetLogRetention gets a reference to the given TopicLogRetention and assigns it to the LogRetention field.
func (o *Topic) SetLogRetention(v TopicLogRetention) {
	o.LogRetention = &v
}

func (o Topic) MarshalJSON() ([]byte, error) {
	toSerialize, err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o Topic) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["name"] = o.Name
	if !IsNil(o.ReplicationFactor) {
		toSerialize["replicationFactor"] = o.ReplicationFactor
	}
	if !IsNil(o.NumberOfPartitions) {
		toSerialize["numberOfPartitions"] = o.NumberOfPartitions
	}
	if !IsNil(o.LogRetention) {
		toSerialize["logRetention"] = o.LogRetention
	}
	return toSerialize, nil
}

type NullableTopic struct {
	value *Topic
	isSet bool
}

func (v NullableTopic) Get() *Topic {
	return v.value
}

func (v *NullableTopic) Set(val *Topic) {
	v.value = val
	v.isSet = true
}

func (v NullableTopic) IsSet() bool {
	return v.isSet
}

func (v *NullableTopic) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableTopic(val *Topic) *NullableTopic {
	return &NullableTopic{value: val, isSet: true}
}

func (v NullableTopic) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableTopic) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
