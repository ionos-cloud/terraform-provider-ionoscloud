/*
 * CLOUD API
 *
 * An enterprise-grade Infrastructure is provided as a Service (IaaS) solution that can be managed through a browser-based \"Data Center Designer\" (DCD) tool or via an easy to use API.   The API allows you to perform a variety of management tasks such as spinning up additional servers, adding volumes, adjusting networking, and so forth. It is designed to allow users to leverage the same power and flexibility found within the DCD visual tool. Both tools are consistent with their concepts and lend well to making the experience smooth and intuitive.
 *
 * API version: 6.0-SDK.1
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ionoscloud

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// NATGatewaysApiService NATGatewaysApi service
type NATGatewaysApiService service

type ApiDatacentersNatgatewaysDeleteRequest struct {
	ctx _context.Context
	ApiService *NATGatewaysApiService
	datacenterId string
	natGatewayId string
	pretty *bool
	depth *int32
	xContractNumber *int32
}

func (r ApiDatacentersNatgatewaysDeleteRequest) Pretty(pretty bool) ApiDatacentersNatgatewaysDeleteRequest {
	r.pretty = &pretty
	return r
}
func (r ApiDatacentersNatgatewaysDeleteRequest) Depth(depth int32) ApiDatacentersNatgatewaysDeleteRequest {
	r.depth = &depth
	return r
}
func (r ApiDatacentersNatgatewaysDeleteRequest) XContractNumber(xContractNumber int32) ApiDatacentersNatgatewaysDeleteRequest {
	r.xContractNumber = &xContractNumber
	return r
}

func (r ApiDatacentersNatgatewaysDeleteRequest) Execute() (*APIResponse, error) {
	return r.ApiService.DatacentersNatgatewaysDeleteExecute(r)
}

/*
 * DatacentersNatgatewaysDelete Remove a NAT gateway
 * Removes the specified NAT gateway.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param datacenterId The unique ID of the datacenter
 * @param natGatewayId The unique ID of the NAT gateway
 * @return ApiDatacentersNatgatewaysDeleteRequest
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysDelete(ctx _context.Context, datacenterId string, natGatewayId string) ApiDatacentersNatgatewaysDeleteRequest {
	return ApiDatacentersNatgatewaysDeleteRequest{
		ApiService: a,
		ctx: ctx,
		datacenterId: datacenterId,
		natGatewayId: natGatewayId,
	}
}

/*
 * Execute executes the request
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysDeleteExecute(r ApiDatacentersNatgatewaysDeleteRequest) (*APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NATGatewaysApiService.DatacentersNatgatewaysDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/datacenters/{datacenterId}/natgateways/{natGatewayId}"
	localVarPath = strings.Replace(localVarPath, "{"+"datacenterId"+"}", _neturl.PathEscape(parameterToString(r.datacenterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"natGatewayId"+"}", _neturl.PathEscape(parameterToString(r.natGatewayId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.depth != nil {
		localVarQueryParams.Add("depth", parameterToString(*r.depth, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xContractNumber != nil {
		localVarHeaderParams["X-Contract-Number"] = parameterToString(*r.xContractNumber, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Token Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)

	localVarAPIResponse := &APIResponse {
		Response: localVarHTTPResponse,
		Method: localVarHTTPMethod,
		RequestURL: localVarPath,
		Operation: "DatacentersNatgatewaysDelete",
	}

	if err != nil || localVarHTTPResponse == nil {
		return localVarAPIResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarAPIResponse, newErr
			}
			newErr.model = v
		return localVarAPIResponse, newErr
	}

	return localVarAPIResponse, nil
}

type ApiDatacentersNatgatewaysFindByNatGatewayIdRequest struct {
	ctx _context.Context
	ApiService *NATGatewaysApiService
	datacenterId string
	natGatewayId string
	pretty *bool
	depth *int32
	xContractNumber *int32
}

func (r ApiDatacentersNatgatewaysFindByNatGatewayIdRequest) Pretty(pretty bool) ApiDatacentersNatgatewaysFindByNatGatewayIdRequest {
	r.pretty = &pretty
	return r
}
func (r ApiDatacentersNatgatewaysFindByNatGatewayIdRequest) Depth(depth int32) ApiDatacentersNatgatewaysFindByNatGatewayIdRequest {
	r.depth = &depth
	return r
}
func (r ApiDatacentersNatgatewaysFindByNatGatewayIdRequest) XContractNumber(xContractNumber int32) ApiDatacentersNatgatewaysFindByNatGatewayIdRequest {
	r.xContractNumber = &xContractNumber
	return r
}

func (r ApiDatacentersNatgatewaysFindByNatGatewayIdRequest) Execute() (NatGateway, *APIResponse, error) {
	return r.ApiService.DatacentersNatgatewaysFindByNatGatewayIdExecute(r)
}

/*
 * DatacentersNatgatewaysFindByNatGatewayId Retrieve a NAT gateway
 * Retrieves the attributes of a given NAT gateway.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param datacenterId The unique ID of the datacenter
 * @param natGatewayId The unique ID of the NAT gateway
 * @return ApiDatacentersNatgatewaysFindByNatGatewayIdRequest
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysFindByNatGatewayId(ctx _context.Context, datacenterId string, natGatewayId string) ApiDatacentersNatgatewaysFindByNatGatewayIdRequest {
	return ApiDatacentersNatgatewaysFindByNatGatewayIdRequest{
		ApiService: a,
		ctx: ctx,
		datacenterId: datacenterId,
		natGatewayId: natGatewayId,
	}
}

/*
 * Execute executes the request
 * @return NatGateway
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysFindByNatGatewayIdExecute(r ApiDatacentersNatgatewaysFindByNatGatewayIdRequest) (NatGateway, *APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NatGateway
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NATGatewaysApiService.DatacentersNatgatewaysFindByNatGatewayId")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/datacenters/{datacenterId}/natgateways/{natGatewayId}"
	localVarPath = strings.Replace(localVarPath, "{"+"datacenterId"+"}", _neturl.PathEscape(parameterToString(r.datacenterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"natGatewayId"+"}", _neturl.PathEscape(parameterToString(r.natGatewayId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.depth != nil {
		localVarQueryParams.Add("depth", parameterToString(*r.depth, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xContractNumber != nil {
		localVarHeaderParams["X-Contract-Number"] = parameterToString(*r.xContractNumber, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Token Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)

	localVarAPIResponse := &APIResponse {
		Response: localVarHTTPResponse,
		Method: localVarHTTPMethod,
		RequestURL: localVarPath,
		Operation: "DatacentersNatgatewaysFindByNatGatewayId",
	}

	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarAPIResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

type ApiDatacentersNatgatewaysFlowlogsDeleteRequest struct {
	ctx _context.Context
	ApiService *NATGatewaysApiService
	datacenterId string
	natGatewayId string
	flowLogId string
	pretty *bool
	depth *int32
}

func (r ApiDatacentersNatgatewaysFlowlogsDeleteRequest) Pretty(pretty bool) ApiDatacentersNatgatewaysFlowlogsDeleteRequest {
	r.pretty = &pretty
	return r
}
func (r ApiDatacentersNatgatewaysFlowlogsDeleteRequest) Depth(depth int32) ApiDatacentersNatgatewaysFlowlogsDeleteRequest {
	r.depth = &depth
	return r
}

func (r ApiDatacentersNatgatewaysFlowlogsDeleteRequest) Execute() (*APIResponse, error) {
	return r.ApiService.DatacentersNatgatewaysFlowlogsDeleteExecute(r)
}

/*
 * DatacentersNatgatewaysFlowlogsDelete Remove Flow Log from NAT Gateway
 * This will remove a flow log from the NAT gateway.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param datacenterId The unique ID of the datacenter
 * @param natGatewayId The unique ID of the NAT gateway
 * @param flowLogId The unique ID of the flow log
 * @return ApiDatacentersNatgatewaysFlowlogsDeleteRequest
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysFlowlogsDelete(ctx _context.Context, datacenterId string, natGatewayId string, flowLogId string) ApiDatacentersNatgatewaysFlowlogsDeleteRequest {
	return ApiDatacentersNatgatewaysFlowlogsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		datacenterId: datacenterId,
		natGatewayId: natGatewayId,
		flowLogId: flowLogId,
	}
}

/*
 * Execute executes the request
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysFlowlogsDeleteExecute(r ApiDatacentersNatgatewaysFlowlogsDeleteRequest) (*APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NATGatewaysApiService.DatacentersNatgatewaysFlowlogsDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/datacenters/{datacenterId}/natgateways/{natGatewayId}/flowlogs/{flowLogId}"
	localVarPath = strings.Replace(localVarPath, "{"+"datacenterId"+"}", _neturl.PathEscape(parameterToString(r.datacenterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"natGatewayId"+"}", _neturl.PathEscape(parameterToString(r.natGatewayId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"flowLogId"+"}", _neturl.PathEscape(parameterToString(r.flowLogId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.depth != nil {
		localVarQueryParams.Add("depth", parameterToString(*r.depth, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Token Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)

	localVarAPIResponse := &APIResponse {
		Response: localVarHTTPResponse,
		Method: localVarHTTPMethod,
		RequestURL: localVarPath,
		Operation: "DatacentersNatgatewaysFlowlogsDelete",
	}

	if err != nil || localVarHTTPResponse == nil {
		return localVarAPIResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarAPIResponse, newErr
			}
			newErr.model = v
		return localVarAPIResponse, newErr
	}

	return localVarAPIResponse, nil
}

type ApiDatacentersNatgatewaysFlowlogsFindByFlowLogIdRequest struct {
	ctx _context.Context
	ApiService *NATGatewaysApiService
	datacenterId string
	natGatewayId string
	flowLogId string
	pretty *bool
	depth *int32
}

func (r ApiDatacentersNatgatewaysFlowlogsFindByFlowLogIdRequest) Pretty(pretty bool) ApiDatacentersNatgatewaysFlowlogsFindByFlowLogIdRequest {
	r.pretty = &pretty
	return r
}
func (r ApiDatacentersNatgatewaysFlowlogsFindByFlowLogIdRequest) Depth(depth int32) ApiDatacentersNatgatewaysFlowlogsFindByFlowLogIdRequest {
	r.depth = &depth
	return r
}

func (r ApiDatacentersNatgatewaysFlowlogsFindByFlowLogIdRequest) Execute() (FlowLog, *APIResponse, error) {
	return r.ApiService.DatacentersNatgatewaysFlowlogsFindByFlowLogIdExecute(r)
}

/*
 * DatacentersNatgatewaysFlowlogsFindByFlowLogId Retrieve a Flow Log of the NAT Gateway
 * This will return a Flow Log of the NAT Gateway.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param datacenterId The unique ID of the datacenter
 * @param natGatewayId The unique ID of the NAT gateway
 * @param flowLogId The unique ID of the flow log
 * @return ApiDatacentersNatgatewaysFlowlogsFindByFlowLogIdRequest
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysFlowlogsFindByFlowLogId(ctx _context.Context, datacenterId string, natGatewayId string, flowLogId string) ApiDatacentersNatgatewaysFlowlogsFindByFlowLogIdRequest {
	return ApiDatacentersNatgatewaysFlowlogsFindByFlowLogIdRequest{
		ApiService: a,
		ctx: ctx,
		datacenterId: datacenterId,
		natGatewayId: natGatewayId,
		flowLogId: flowLogId,
	}
}

/*
 * Execute executes the request
 * @return FlowLog
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysFlowlogsFindByFlowLogIdExecute(r ApiDatacentersNatgatewaysFlowlogsFindByFlowLogIdRequest) (FlowLog, *APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FlowLog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NATGatewaysApiService.DatacentersNatgatewaysFlowlogsFindByFlowLogId")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/datacenters/{datacenterId}/natgateways/{natGatewayId}/flowlogs/{flowLogId}"
	localVarPath = strings.Replace(localVarPath, "{"+"datacenterId"+"}", _neturl.PathEscape(parameterToString(r.datacenterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"natGatewayId"+"}", _neturl.PathEscape(parameterToString(r.natGatewayId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"flowLogId"+"}", _neturl.PathEscape(parameterToString(r.flowLogId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.depth != nil {
		localVarQueryParams.Add("depth", parameterToString(*r.depth, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Token Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)

	localVarAPIResponse := &APIResponse {
		Response: localVarHTTPResponse,
		Method: localVarHTTPMethod,
		RequestURL: localVarPath,
		Operation: "DatacentersNatgatewaysFlowlogsFindByFlowLogId",
	}

	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarAPIResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

type ApiDatacentersNatgatewaysFlowlogsGetRequest struct {
	ctx _context.Context
	ApiService *NATGatewaysApiService
	datacenterId string
	natGatewayId string
	pretty *bool
	depth *int32
	offset *int32
	limit *int32
}

func (r ApiDatacentersNatgatewaysFlowlogsGetRequest) Pretty(pretty bool) ApiDatacentersNatgatewaysFlowlogsGetRequest {
	r.pretty = &pretty
	return r
}
func (r ApiDatacentersNatgatewaysFlowlogsGetRequest) Depth(depth int32) ApiDatacentersNatgatewaysFlowlogsGetRequest {
	r.depth = &depth
	return r
}
func (r ApiDatacentersNatgatewaysFlowlogsGetRequest) Offset(offset int32) ApiDatacentersNatgatewaysFlowlogsGetRequest {
	r.offset = &offset
	return r
}
func (r ApiDatacentersNatgatewaysFlowlogsGetRequest) Limit(limit int32) ApiDatacentersNatgatewaysFlowlogsGetRequest {
	r.limit = &limit
	return r
}

func (r ApiDatacentersNatgatewaysFlowlogsGetRequest) Execute() (FlowLogs, *APIResponse, error) {
	return r.ApiService.DatacentersNatgatewaysFlowlogsGetExecute(r)
}

/*
 * DatacentersNatgatewaysFlowlogsGet List NAT Gateway Flow Logs
 * You can retrieve a list of Flow Logs of the NAT Gateway.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param datacenterId The unique ID of the datacenter
 * @param natGatewayId The unique ID of the NAT gateway
 * @return ApiDatacentersNatgatewaysFlowlogsGetRequest
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysFlowlogsGet(ctx _context.Context, datacenterId string, natGatewayId string) ApiDatacentersNatgatewaysFlowlogsGetRequest {
	return ApiDatacentersNatgatewaysFlowlogsGetRequest{
		ApiService: a,
		ctx: ctx,
		datacenterId: datacenterId,
		natGatewayId: natGatewayId,
	}
}

/*
 * Execute executes the request
 * @return FlowLogs
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysFlowlogsGetExecute(r ApiDatacentersNatgatewaysFlowlogsGetRequest) (FlowLogs, *APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FlowLogs
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NATGatewaysApiService.DatacentersNatgatewaysFlowlogsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/datacenters/{datacenterId}/natgateways/{natGatewayId}/flowlogs"
	localVarPath = strings.Replace(localVarPath, "{"+"datacenterId"+"}", _neturl.PathEscape(parameterToString(r.datacenterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"natGatewayId"+"}", _neturl.PathEscape(parameterToString(r.natGatewayId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.depth != nil {
		localVarQueryParams.Add("depth", parameterToString(*r.depth, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Token Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)

	localVarAPIResponse := &APIResponse {
		Response: localVarHTTPResponse,
		Method: localVarHTTPMethod,
		RequestURL: localVarPath,
		Operation: "DatacentersNatgatewaysFlowlogsGet",
	}

	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarAPIResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

type ApiDatacentersNatgatewaysFlowlogsPatchRequest struct {
	ctx _context.Context
	ApiService *NATGatewaysApiService
	datacenterId string
	natGatewayId string
	flowLogId string
	natGatewayFlowLogProperties *FlowLogProperties
	pretty *bool
	depth *int32
}

func (r ApiDatacentersNatgatewaysFlowlogsPatchRequest) NatGatewayFlowLogProperties(natGatewayFlowLogProperties FlowLogProperties) ApiDatacentersNatgatewaysFlowlogsPatchRequest {
	r.natGatewayFlowLogProperties = &natGatewayFlowLogProperties
	return r
}
func (r ApiDatacentersNatgatewaysFlowlogsPatchRequest) Pretty(pretty bool) ApiDatacentersNatgatewaysFlowlogsPatchRequest {
	r.pretty = &pretty
	return r
}
func (r ApiDatacentersNatgatewaysFlowlogsPatchRequest) Depth(depth int32) ApiDatacentersNatgatewaysFlowlogsPatchRequest {
	r.depth = &depth
	return r
}

func (r ApiDatacentersNatgatewaysFlowlogsPatchRequest) Execute() (FlowLog, *APIResponse, error) {
	return r.ApiService.DatacentersNatgatewaysFlowlogsPatchExecute(r)
}

/*
 * DatacentersNatgatewaysFlowlogsPatch Partially modify a Flow Log of the NAT Gateway
 * You can use to partially update a Flow Log of a NAT Gateway.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param datacenterId The unique ID of the datacenter
 * @param natGatewayId The unique ID of the NAT gateway
 * @param flowLogId The unique ID of the flow log
 * @return ApiDatacentersNatgatewaysFlowlogsPatchRequest
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysFlowlogsPatch(ctx _context.Context, datacenterId string, natGatewayId string, flowLogId string) ApiDatacentersNatgatewaysFlowlogsPatchRequest {
	return ApiDatacentersNatgatewaysFlowlogsPatchRequest{
		ApiService: a,
		ctx: ctx,
		datacenterId: datacenterId,
		natGatewayId: natGatewayId,
		flowLogId: flowLogId,
	}
}

/*
 * Execute executes the request
 * @return FlowLog
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysFlowlogsPatchExecute(r ApiDatacentersNatgatewaysFlowlogsPatchRequest) (FlowLog, *APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FlowLog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NATGatewaysApiService.DatacentersNatgatewaysFlowlogsPatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/datacenters/{datacenterId}/natgateways/{natGatewayId}/flowlogs/{flowLogId}"
	localVarPath = strings.Replace(localVarPath, "{"+"datacenterId"+"}", _neturl.PathEscape(parameterToString(r.datacenterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"natGatewayId"+"}", _neturl.PathEscape(parameterToString(r.natGatewayId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"flowLogId"+"}", _neturl.PathEscape(parameterToString(r.flowLogId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.natGatewayFlowLogProperties == nil {
		return localVarReturnValue, nil, reportError("natGatewayFlowLogProperties is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.depth != nil {
		localVarQueryParams.Add("depth", parameterToString(*r.depth, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.natGatewayFlowLogProperties
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Token Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)

	localVarAPIResponse := &APIResponse {
		Response: localVarHTTPResponse,
		Method: localVarHTTPMethod,
		RequestURL: localVarPath,
		Operation: "DatacentersNatgatewaysFlowlogsPatch",
	}

	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarAPIResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

type ApiDatacentersNatgatewaysFlowlogsPostRequest struct {
	ctx _context.Context
	ApiService *NATGatewaysApiService
	datacenterId string
	natGatewayId string
	natGatewayFlowLog *FlowLog
	pretty *bool
	depth *int32
}

func (r ApiDatacentersNatgatewaysFlowlogsPostRequest) NatGatewayFlowLog(natGatewayFlowLog FlowLog) ApiDatacentersNatgatewaysFlowlogsPostRequest {
	r.natGatewayFlowLog = &natGatewayFlowLog
	return r
}
func (r ApiDatacentersNatgatewaysFlowlogsPostRequest) Pretty(pretty bool) ApiDatacentersNatgatewaysFlowlogsPostRequest {
	r.pretty = &pretty
	return r
}
func (r ApiDatacentersNatgatewaysFlowlogsPostRequest) Depth(depth int32) ApiDatacentersNatgatewaysFlowlogsPostRequest {
	r.depth = &depth
	return r
}

func (r ApiDatacentersNatgatewaysFlowlogsPostRequest) Execute() (FlowLog, *APIResponse, error) {
	return r.ApiService.DatacentersNatgatewaysFlowlogsPostExecute(r)
}

/*
 * DatacentersNatgatewaysFlowlogsPost Add a NAT Gateways Flow Log
 * This will add a new Flow Log to the NAT Gateway.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param datacenterId The unique ID of the datacenter
 * @param natGatewayId The unique ID of the NAT gateway
 * @return ApiDatacentersNatgatewaysFlowlogsPostRequest
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysFlowlogsPost(ctx _context.Context, datacenterId string, natGatewayId string) ApiDatacentersNatgatewaysFlowlogsPostRequest {
	return ApiDatacentersNatgatewaysFlowlogsPostRequest{
		ApiService: a,
		ctx: ctx,
		datacenterId: datacenterId,
		natGatewayId: natGatewayId,
	}
}

/*
 * Execute executes the request
 * @return FlowLog
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysFlowlogsPostExecute(r ApiDatacentersNatgatewaysFlowlogsPostRequest) (FlowLog, *APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FlowLog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NATGatewaysApiService.DatacentersNatgatewaysFlowlogsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/datacenters/{datacenterId}/natgateways/{natGatewayId}/flowlogs"
	localVarPath = strings.Replace(localVarPath, "{"+"datacenterId"+"}", _neturl.PathEscape(parameterToString(r.datacenterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"natGatewayId"+"}", _neturl.PathEscape(parameterToString(r.natGatewayId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.natGatewayFlowLog == nil {
		return localVarReturnValue, nil, reportError("natGatewayFlowLog is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.depth != nil {
		localVarQueryParams.Add("depth", parameterToString(*r.depth, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.natGatewayFlowLog
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Token Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)

	localVarAPIResponse := &APIResponse {
		Response: localVarHTTPResponse,
		Method: localVarHTTPMethod,
		RequestURL: localVarPath,
		Operation: "DatacentersNatgatewaysFlowlogsPost",
	}

	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarAPIResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

type ApiDatacentersNatgatewaysFlowlogsPutRequest struct {
	ctx _context.Context
	ApiService *NATGatewaysApiService
	datacenterId string
	natGatewayId string
	flowLogId string
	natGatewayFlowLog *FlowLogPut
	pretty *bool
	depth *int32
}

func (r ApiDatacentersNatgatewaysFlowlogsPutRequest) NatGatewayFlowLog(natGatewayFlowLog FlowLogPut) ApiDatacentersNatgatewaysFlowlogsPutRequest {
	r.natGatewayFlowLog = &natGatewayFlowLog
	return r
}
func (r ApiDatacentersNatgatewaysFlowlogsPutRequest) Pretty(pretty bool) ApiDatacentersNatgatewaysFlowlogsPutRequest {
	r.pretty = &pretty
	return r
}
func (r ApiDatacentersNatgatewaysFlowlogsPutRequest) Depth(depth int32) ApiDatacentersNatgatewaysFlowlogsPutRequest {
	r.depth = &depth
	return r
}

func (r ApiDatacentersNatgatewaysFlowlogsPutRequest) Execute() (FlowLog, *APIResponse, error) {
	return r.ApiService.DatacentersNatgatewaysFlowlogsPutExecute(r)
}

/*
 * DatacentersNatgatewaysFlowlogsPut Modify a Flow Log of the NAT Gateway
 * You can use to update a Flow Log of the NAT Gateway.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param datacenterId The unique ID of the datacenter
 * @param natGatewayId The unique ID of the NAT gateway
 * @param flowLogId The unique ID of the flow log
 * @return ApiDatacentersNatgatewaysFlowlogsPutRequest
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysFlowlogsPut(ctx _context.Context, datacenterId string, natGatewayId string, flowLogId string) ApiDatacentersNatgatewaysFlowlogsPutRequest {
	return ApiDatacentersNatgatewaysFlowlogsPutRequest{
		ApiService: a,
		ctx: ctx,
		datacenterId: datacenterId,
		natGatewayId: natGatewayId,
		flowLogId: flowLogId,
	}
}

/*
 * Execute executes the request
 * @return FlowLog
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysFlowlogsPutExecute(r ApiDatacentersNatgatewaysFlowlogsPutRequest) (FlowLog, *APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FlowLog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NATGatewaysApiService.DatacentersNatgatewaysFlowlogsPut")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/datacenters/{datacenterId}/natgateways/{natGatewayId}/flowlogs/{flowLogId}"
	localVarPath = strings.Replace(localVarPath, "{"+"datacenterId"+"}", _neturl.PathEscape(parameterToString(r.datacenterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"natGatewayId"+"}", _neturl.PathEscape(parameterToString(r.natGatewayId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"flowLogId"+"}", _neturl.PathEscape(parameterToString(r.flowLogId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.natGatewayFlowLog == nil {
		return localVarReturnValue, nil, reportError("natGatewayFlowLog is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.depth != nil {
		localVarQueryParams.Add("depth", parameterToString(*r.depth, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.natGatewayFlowLog
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Token Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)

	localVarAPIResponse := &APIResponse {
		Response: localVarHTTPResponse,
		Method: localVarHTTPMethod,
		RequestURL: localVarPath,
		Operation: "DatacentersNatgatewaysFlowlogsPut",
	}

	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarAPIResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

type ApiDatacentersNatgatewaysGetRequest struct {
	ctx _context.Context
	ApiService *NATGatewaysApiService
	datacenterId string
	pretty *bool
	depth *int32
	xContractNumber *int32
}

func (r ApiDatacentersNatgatewaysGetRequest) Pretty(pretty bool) ApiDatacentersNatgatewaysGetRequest {
	r.pretty = &pretty
	return r
}
func (r ApiDatacentersNatgatewaysGetRequest) Depth(depth int32) ApiDatacentersNatgatewaysGetRequest {
	r.depth = &depth
	return r
}
func (r ApiDatacentersNatgatewaysGetRequest) XContractNumber(xContractNumber int32) ApiDatacentersNatgatewaysGetRequest {
	r.xContractNumber = &xContractNumber
	return r
}

func (r ApiDatacentersNatgatewaysGetRequest) Execute() (NatGateways, *APIResponse, error) {
	return r.ApiService.DatacentersNatgatewaysGetExecute(r)
}

/*
 * DatacentersNatgatewaysGet List NAT Gateways
 * Retrieve a list of NAT Gateways within the datacenter.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param datacenterId The unique ID of the datacenter
 * @return ApiDatacentersNatgatewaysGetRequest
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysGet(ctx _context.Context, datacenterId string) ApiDatacentersNatgatewaysGetRequest {
	return ApiDatacentersNatgatewaysGetRequest{
		ApiService: a,
		ctx: ctx,
		datacenterId: datacenterId,
	}
}

/*
 * Execute executes the request
 * @return NatGateways
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysGetExecute(r ApiDatacentersNatgatewaysGetRequest) (NatGateways, *APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NatGateways
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NATGatewaysApiService.DatacentersNatgatewaysGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/datacenters/{datacenterId}/natgateways"
	localVarPath = strings.Replace(localVarPath, "{"+"datacenterId"+"}", _neturl.PathEscape(parameterToString(r.datacenterId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.depth != nil {
		localVarQueryParams.Add("depth", parameterToString(*r.depth, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xContractNumber != nil {
		localVarHeaderParams["X-Contract-Number"] = parameterToString(*r.xContractNumber, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Token Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)

	localVarAPIResponse := &APIResponse {
		Response: localVarHTTPResponse,
		Method: localVarHTTPMethod,
		RequestURL: localVarPath,
		Operation: "DatacentersNatgatewaysGet",
	}

	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarAPIResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

type ApiDatacentersNatgatewaysPatchRequest struct {
	ctx _context.Context
	ApiService *NATGatewaysApiService
	datacenterId string
	natGatewayId string
	natGatewayProperties *NatGatewayProperties
	pretty *bool
	depth *int32
	xContractNumber *int32
}

func (r ApiDatacentersNatgatewaysPatchRequest) NatGatewayProperties(natGatewayProperties NatGatewayProperties) ApiDatacentersNatgatewaysPatchRequest {
	r.natGatewayProperties = &natGatewayProperties
	return r
}
func (r ApiDatacentersNatgatewaysPatchRequest) Pretty(pretty bool) ApiDatacentersNatgatewaysPatchRequest {
	r.pretty = &pretty
	return r
}
func (r ApiDatacentersNatgatewaysPatchRequest) Depth(depth int32) ApiDatacentersNatgatewaysPatchRequest {
	r.depth = &depth
	return r
}
func (r ApiDatacentersNatgatewaysPatchRequest) XContractNumber(xContractNumber int32) ApiDatacentersNatgatewaysPatchRequest {
	r.xContractNumber = &xContractNumber
	return r
}

func (r ApiDatacentersNatgatewaysPatchRequest) Execute() (NatGateway, *APIResponse, error) {
	return r.ApiService.DatacentersNatgatewaysPatchExecute(r)
}

/*
 * DatacentersNatgatewaysPatch Partially update a NAT gateway
 * Partially update the attributes of a given NAT gateway
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param datacenterId The unique ID of the datacenter
 * @param natGatewayId The unique ID of the NAT gateway
 * @return ApiDatacentersNatgatewaysPatchRequest
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysPatch(ctx _context.Context, datacenterId string, natGatewayId string) ApiDatacentersNatgatewaysPatchRequest {
	return ApiDatacentersNatgatewaysPatchRequest{
		ApiService: a,
		ctx: ctx,
		datacenterId: datacenterId,
		natGatewayId: natGatewayId,
	}
}

/*
 * Execute executes the request
 * @return NatGateway
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysPatchExecute(r ApiDatacentersNatgatewaysPatchRequest) (NatGateway, *APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NatGateway
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NATGatewaysApiService.DatacentersNatgatewaysPatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/datacenters/{datacenterId}/natgateways/{natGatewayId}"
	localVarPath = strings.Replace(localVarPath, "{"+"datacenterId"+"}", _neturl.PathEscape(parameterToString(r.datacenterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"natGatewayId"+"}", _neturl.PathEscape(parameterToString(r.natGatewayId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.natGatewayProperties == nil {
		return localVarReturnValue, nil, reportError("natGatewayProperties is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.depth != nil {
		localVarQueryParams.Add("depth", parameterToString(*r.depth, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xContractNumber != nil {
		localVarHeaderParams["X-Contract-Number"] = parameterToString(*r.xContractNumber, "")
	}
	// body params
	localVarPostBody = r.natGatewayProperties
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Token Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)

	localVarAPIResponse := &APIResponse {
		Response: localVarHTTPResponse,
		Method: localVarHTTPMethod,
		RequestURL: localVarPath,
		Operation: "DatacentersNatgatewaysPatch",
	}

	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarAPIResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

type ApiDatacentersNatgatewaysPostRequest struct {
	ctx _context.Context
	ApiService *NATGatewaysApiService
	datacenterId string
	natGateway *NatGateway
	pretty *bool
	depth *int32
	xContractNumber *int32
}

func (r ApiDatacentersNatgatewaysPostRequest) NatGateway(natGateway NatGateway) ApiDatacentersNatgatewaysPostRequest {
	r.natGateway = &natGateway
	return r
}
func (r ApiDatacentersNatgatewaysPostRequest) Pretty(pretty bool) ApiDatacentersNatgatewaysPostRequest {
	r.pretty = &pretty
	return r
}
func (r ApiDatacentersNatgatewaysPostRequest) Depth(depth int32) ApiDatacentersNatgatewaysPostRequest {
	r.depth = &depth
	return r
}
func (r ApiDatacentersNatgatewaysPostRequest) XContractNumber(xContractNumber int32) ApiDatacentersNatgatewaysPostRequest {
	r.xContractNumber = &xContractNumber
	return r
}

func (r ApiDatacentersNatgatewaysPostRequest) Execute() (NatGateway, *APIResponse, error) {
	return r.ApiService.DatacentersNatgatewaysPostExecute(r)
}

/*
 * DatacentersNatgatewaysPost Create a NAT Gateway
 * Creates a NAT Gateway within the datacenter. User should be the contract owner or a admin or a user with createInternetAccess privilege
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param datacenterId The unique ID of the datacenter
 * @return ApiDatacentersNatgatewaysPostRequest
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysPost(ctx _context.Context, datacenterId string) ApiDatacentersNatgatewaysPostRequest {
	return ApiDatacentersNatgatewaysPostRequest{
		ApiService: a,
		ctx: ctx,
		datacenterId: datacenterId,
	}
}

/*
 * Execute executes the request
 * @return NatGateway
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysPostExecute(r ApiDatacentersNatgatewaysPostRequest) (NatGateway, *APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NatGateway
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NATGatewaysApiService.DatacentersNatgatewaysPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/datacenters/{datacenterId}/natgateways"
	localVarPath = strings.Replace(localVarPath, "{"+"datacenterId"+"}", _neturl.PathEscape(parameterToString(r.datacenterId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.natGateway == nil {
		return localVarReturnValue, nil, reportError("natGateway is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.depth != nil {
		localVarQueryParams.Add("depth", parameterToString(*r.depth, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xContractNumber != nil {
		localVarHeaderParams["X-Contract-Number"] = parameterToString(*r.xContractNumber, "")
	}
	// body params
	localVarPostBody = r.natGateway
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Token Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)

	localVarAPIResponse := &APIResponse {
		Response: localVarHTTPResponse,
		Method: localVarHTTPMethod,
		RequestURL: localVarPath,
		Operation: "DatacentersNatgatewaysPost",
	}

	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarAPIResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

type ApiDatacentersNatgatewaysPutRequest struct {
	ctx _context.Context
	ApiService *NATGatewaysApiService
	datacenterId string
	natGatewayId string
	natGateway *NatGatewayPut
	pretty *bool
	depth *int32
	xContractNumber *int32
	offset *int32
	limit *int32
}

func (r ApiDatacentersNatgatewaysPutRequest) NatGateway(natGateway NatGatewayPut) ApiDatacentersNatgatewaysPutRequest {
	r.natGateway = &natGateway
	return r
}
func (r ApiDatacentersNatgatewaysPutRequest) Pretty(pretty bool) ApiDatacentersNatgatewaysPutRequest {
	r.pretty = &pretty
	return r
}
func (r ApiDatacentersNatgatewaysPutRequest) Depth(depth int32) ApiDatacentersNatgatewaysPutRequest {
	r.depth = &depth
	return r
}
func (r ApiDatacentersNatgatewaysPutRequest) XContractNumber(xContractNumber int32) ApiDatacentersNatgatewaysPutRequest {
	r.xContractNumber = &xContractNumber
	return r
}
func (r ApiDatacentersNatgatewaysPutRequest) Offset(offset int32) ApiDatacentersNatgatewaysPutRequest {
	r.offset = &offset
	return r
}
func (r ApiDatacentersNatgatewaysPutRequest) Limit(limit int32) ApiDatacentersNatgatewaysPutRequest {
	r.limit = &limit
	return r
}

func (r ApiDatacentersNatgatewaysPutRequest) Execute() (NatGateway, *APIResponse, error) {
	return r.ApiService.DatacentersNatgatewaysPutExecute(r)
}

/*
 * DatacentersNatgatewaysPut Update a NAT gateway
 * Update the attributes of a given NAT gateway
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param datacenterId The unique ID of the datacenter
 * @param natGatewayId The unique ID of the NAT gateway
 * @return ApiDatacentersNatgatewaysPutRequest
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysPut(ctx _context.Context, datacenterId string, natGatewayId string) ApiDatacentersNatgatewaysPutRequest {
	return ApiDatacentersNatgatewaysPutRequest{
		ApiService: a,
		ctx: ctx,
		datacenterId: datacenterId,
		natGatewayId: natGatewayId,
	}
}

/*
 * Execute executes the request
 * @return NatGateway
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysPutExecute(r ApiDatacentersNatgatewaysPutRequest) (NatGateway, *APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NatGateway
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NATGatewaysApiService.DatacentersNatgatewaysPut")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/datacenters/{datacenterId}/natgateways/{natGatewayId}"
	localVarPath = strings.Replace(localVarPath, "{"+"datacenterId"+"}", _neturl.PathEscape(parameterToString(r.datacenterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"natGatewayId"+"}", _neturl.PathEscape(parameterToString(r.natGatewayId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.natGateway == nil {
		return localVarReturnValue, nil, reportError("natGateway is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.depth != nil {
		localVarQueryParams.Add("depth", parameterToString(*r.depth, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xContractNumber != nil {
		localVarHeaderParams["X-Contract-Number"] = parameterToString(*r.xContractNumber, "")
	}
	// body params
	localVarPostBody = r.natGateway
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Token Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)

	localVarAPIResponse := &APIResponse {
		Response: localVarHTTPResponse,
		Method: localVarHTTPMethod,
		RequestURL: localVarPath,
		Operation: "DatacentersNatgatewaysPut",
	}

	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarAPIResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

type ApiDatacentersNatgatewaysRulesDeleteRequest struct {
	ctx _context.Context
	ApiService *NATGatewaysApiService
	datacenterId string
	natGatewayId string
	natGatewayRuleId string
	pretty *bool
	depth *int32
	xContractNumber *int32
}

func (r ApiDatacentersNatgatewaysRulesDeleteRequest) Pretty(pretty bool) ApiDatacentersNatgatewaysRulesDeleteRequest {
	r.pretty = &pretty
	return r
}
func (r ApiDatacentersNatgatewaysRulesDeleteRequest) Depth(depth int32) ApiDatacentersNatgatewaysRulesDeleteRequest {
	r.depth = &depth
	return r
}
func (r ApiDatacentersNatgatewaysRulesDeleteRequest) XContractNumber(xContractNumber int32) ApiDatacentersNatgatewaysRulesDeleteRequest {
	r.xContractNumber = &xContractNumber
	return r
}

func (r ApiDatacentersNatgatewaysRulesDeleteRequest) Execute() (*APIResponse, error) {
	return r.ApiService.DatacentersNatgatewaysRulesDeleteExecute(r)
}

/*
 * DatacentersNatgatewaysRulesDelete Remove rule from NAT Gateway
 * This will remove a rule from the NAT gateway.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param datacenterId The unique ID of the datacenter
 * @param natGatewayId The unique ID of the NAT gateway
 * @param natGatewayRuleId The unique ID of the NAT gateway rule
 * @return ApiDatacentersNatgatewaysRulesDeleteRequest
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysRulesDelete(ctx _context.Context, datacenterId string, natGatewayId string, natGatewayRuleId string) ApiDatacentersNatgatewaysRulesDeleteRequest {
	return ApiDatacentersNatgatewaysRulesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		datacenterId: datacenterId,
		natGatewayId: natGatewayId,
		natGatewayRuleId: natGatewayRuleId,
	}
}

/*
 * Execute executes the request
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysRulesDeleteExecute(r ApiDatacentersNatgatewaysRulesDeleteRequest) (*APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NATGatewaysApiService.DatacentersNatgatewaysRulesDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/datacenters/{datacenterId}/natgateways/{natGatewayId}/rules/{natGatewayRuleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"datacenterId"+"}", _neturl.PathEscape(parameterToString(r.datacenterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"natGatewayId"+"}", _neturl.PathEscape(parameterToString(r.natGatewayId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"natGatewayRuleId"+"}", _neturl.PathEscape(parameterToString(r.natGatewayRuleId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.depth != nil {
		localVarQueryParams.Add("depth", parameterToString(*r.depth, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xContractNumber != nil {
		localVarHeaderParams["X-Contract-Number"] = parameterToString(*r.xContractNumber, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Token Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)

	localVarAPIResponse := &APIResponse {
		Response: localVarHTTPResponse,
		Method: localVarHTTPMethod,
		RequestURL: localVarPath,
		Operation: "DatacentersNatgatewaysRulesDelete",
	}

	if err != nil || localVarHTTPResponse == nil {
		return localVarAPIResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarAPIResponse, newErr
			}
			newErr.model = v
		return localVarAPIResponse, newErr
	}

	return localVarAPIResponse, nil
}

type ApiDatacentersNatgatewaysRulesFindByNatGatewayRuleIdRequest struct {
	ctx _context.Context
	ApiService *NATGatewaysApiService
	datacenterId string
	natGatewayId string
	natGatewayRuleId string
	pretty *bool
	depth *int32
	xContractNumber *int32
}

func (r ApiDatacentersNatgatewaysRulesFindByNatGatewayRuleIdRequest) Pretty(pretty bool) ApiDatacentersNatgatewaysRulesFindByNatGatewayRuleIdRequest {
	r.pretty = &pretty
	return r
}
func (r ApiDatacentersNatgatewaysRulesFindByNatGatewayRuleIdRequest) Depth(depth int32) ApiDatacentersNatgatewaysRulesFindByNatGatewayRuleIdRequest {
	r.depth = &depth
	return r
}
func (r ApiDatacentersNatgatewaysRulesFindByNatGatewayRuleIdRequest) XContractNumber(xContractNumber int32) ApiDatacentersNatgatewaysRulesFindByNatGatewayRuleIdRequest {
	r.xContractNumber = &xContractNumber
	return r
}

func (r ApiDatacentersNatgatewaysRulesFindByNatGatewayRuleIdRequest) Execute() (NatGatewayRule, *APIResponse, error) {
	return r.ApiService.DatacentersNatgatewaysRulesFindByNatGatewayRuleIdExecute(r)
}

/*
 * DatacentersNatgatewaysRulesFindByNatGatewayRuleId Retrieve a NAT Gateway Rule
 * Retrieves the attributes of a given NAT gateway rule.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param datacenterId The unique ID of the datacenter
 * @param natGatewayId The unique ID of the NAT gateway
 * @param natGatewayRuleId The unique ID of the NAT gateway rule
 * @return ApiDatacentersNatgatewaysRulesFindByNatGatewayRuleIdRequest
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysRulesFindByNatGatewayRuleId(ctx _context.Context, datacenterId string, natGatewayId string, natGatewayRuleId string) ApiDatacentersNatgatewaysRulesFindByNatGatewayRuleIdRequest {
	return ApiDatacentersNatgatewaysRulesFindByNatGatewayRuleIdRequest{
		ApiService: a,
		ctx: ctx,
		datacenterId: datacenterId,
		natGatewayId: natGatewayId,
		natGatewayRuleId: natGatewayRuleId,
	}
}

/*
 * Execute executes the request
 * @return NatGatewayRule
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysRulesFindByNatGatewayRuleIdExecute(r ApiDatacentersNatgatewaysRulesFindByNatGatewayRuleIdRequest) (NatGatewayRule, *APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NatGatewayRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NATGatewaysApiService.DatacentersNatgatewaysRulesFindByNatGatewayRuleId")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/datacenters/{datacenterId}/natgateways/{natGatewayId}/rules/{natGatewayRuleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"datacenterId"+"}", _neturl.PathEscape(parameterToString(r.datacenterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"natGatewayId"+"}", _neturl.PathEscape(parameterToString(r.natGatewayId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"natGatewayRuleId"+"}", _neturl.PathEscape(parameterToString(r.natGatewayRuleId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.depth != nil {
		localVarQueryParams.Add("depth", parameterToString(*r.depth, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xContractNumber != nil {
		localVarHeaderParams["X-Contract-Number"] = parameterToString(*r.xContractNumber, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Token Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)

	localVarAPIResponse := &APIResponse {
		Response: localVarHTTPResponse,
		Method: localVarHTTPMethod,
		RequestURL: localVarPath,
		Operation: "DatacentersNatgatewaysRulesFindByNatGatewayRuleId",
	}

	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarAPIResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

type ApiDatacentersNatgatewaysRulesGetRequest struct {
	ctx _context.Context
	ApiService *NATGatewaysApiService
	datacenterId string
	natGatewayId string
	pretty *bool
	depth *int32
	xContractNumber *int32
}

func (r ApiDatacentersNatgatewaysRulesGetRequest) Pretty(pretty bool) ApiDatacentersNatgatewaysRulesGetRequest {
	r.pretty = &pretty
	return r
}
func (r ApiDatacentersNatgatewaysRulesGetRequest) Depth(depth int32) ApiDatacentersNatgatewaysRulesGetRequest {
	r.depth = &depth
	return r
}
func (r ApiDatacentersNatgatewaysRulesGetRequest) XContractNumber(xContractNumber int32) ApiDatacentersNatgatewaysRulesGetRequest {
	r.xContractNumber = &xContractNumber
	return r
}

func (r ApiDatacentersNatgatewaysRulesGetRequest) Execute() (NatGatewayRules, *APIResponse, error) {
	return r.ApiService.DatacentersNatgatewaysRulesGetExecute(r)
}

/*
 * DatacentersNatgatewaysRulesGet List NAT Gateways Rules
 * Retrieve a list of rules of a NAT Gateway within the datacenter.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param datacenterId The unique ID of the datacenter
 * @param natGatewayId The unique ID of the NAT gateway
 * @return ApiDatacentersNatgatewaysRulesGetRequest
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysRulesGet(ctx _context.Context, datacenterId string, natGatewayId string) ApiDatacentersNatgatewaysRulesGetRequest {
	return ApiDatacentersNatgatewaysRulesGetRequest{
		ApiService: a,
		ctx: ctx,
		datacenterId: datacenterId,
		natGatewayId: natGatewayId,
	}
}

/*
 * Execute executes the request
 * @return NatGatewayRules
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysRulesGetExecute(r ApiDatacentersNatgatewaysRulesGetRequest) (NatGatewayRules, *APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NatGatewayRules
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NATGatewaysApiService.DatacentersNatgatewaysRulesGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/datacenters/{datacenterId}/natgateways/{natGatewayId}/rules"
	localVarPath = strings.Replace(localVarPath, "{"+"datacenterId"+"}", _neturl.PathEscape(parameterToString(r.datacenterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"natGatewayId"+"}", _neturl.PathEscape(parameterToString(r.natGatewayId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.depth != nil {
		localVarQueryParams.Add("depth", parameterToString(*r.depth, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xContractNumber != nil {
		localVarHeaderParams["X-Contract-Number"] = parameterToString(*r.xContractNumber, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Token Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)

	localVarAPIResponse := &APIResponse {
		Response: localVarHTTPResponse,
		Method: localVarHTTPMethod,
		RequestURL: localVarPath,
		Operation: "DatacentersNatgatewaysRulesGet",
	}

	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarAPIResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

type ApiDatacentersNatgatewaysRulesPatchRequest struct {
	ctx _context.Context
	ApiService *NATGatewaysApiService
	datacenterId string
	natGatewayId string
	natGatewayRuleId string
	natGatewayRuleProperties *NatGatewayRuleProperties
	pretty *bool
	depth *int32
	xContractNumber *int32
}

func (r ApiDatacentersNatgatewaysRulesPatchRequest) NatGatewayRuleProperties(natGatewayRuleProperties NatGatewayRuleProperties) ApiDatacentersNatgatewaysRulesPatchRequest {
	r.natGatewayRuleProperties = &natGatewayRuleProperties
	return r
}
func (r ApiDatacentersNatgatewaysRulesPatchRequest) Pretty(pretty bool) ApiDatacentersNatgatewaysRulesPatchRequest {
	r.pretty = &pretty
	return r
}
func (r ApiDatacentersNatgatewaysRulesPatchRequest) Depth(depth int32) ApiDatacentersNatgatewaysRulesPatchRequest {
	r.depth = &depth
	return r
}
func (r ApiDatacentersNatgatewaysRulesPatchRequest) XContractNumber(xContractNumber int32) ApiDatacentersNatgatewaysRulesPatchRequest {
	r.xContractNumber = &xContractNumber
	return r
}

func (r ApiDatacentersNatgatewaysRulesPatchRequest) Execute() (NatGatewayRule, *APIResponse, error) {
	return r.ApiService.DatacentersNatgatewaysRulesPatchExecute(r)
}

/*
 * DatacentersNatgatewaysRulesPatch Partially modify a rule of the NAT gateway
 * You can use to partially update a rule of a NAT gateway.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param datacenterId The unique ID of the datacenter
 * @param natGatewayId The unique ID of the NAT gateway
 * @param natGatewayRuleId The unique ID of the NAT gateway rule
 * @return ApiDatacentersNatgatewaysRulesPatchRequest
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysRulesPatch(ctx _context.Context, datacenterId string, natGatewayId string, natGatewayRuleId string) ApiDatacentersNatgatewaysRulesPatchRequest {
	return ApiDatacentersNatgatewaysRulesPatchRequest{
		ApiService: a,
		ctx: ctx,
		datacenterId: datacenterId,
		natGatewayId: natGatewayId,
		natGatewayRuleId: natGatewayRuleId,
	}
}

/*
 * Execute executes the request
 * @return NatGatewayRule
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysRulesPatchExecute(r ApiDatacentersNatgatewaysRulesPatchRequest) (NatGatewayRule, *APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NatGatewayRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NATGatewaysApiService.DatacentersNatgatewaysRulesPatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/datacenters/{datacenterId}/natgateways/{natGatewayId}/rules/{natGatewayRuleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"datacenterId"+"}", _neturl.PathEscape(parameterToString(r.datacenterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"natGatewayId"+"}", _neturl.PathEscape(parameterToString(r.natGatewayId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"natGatewayRuleId"+"}", _neturl.PathEscape(parameterToString(r.natGatewayRuleId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.natGatewayRuleProperties == nil {
		return localVarReturnValue, nil, reportError("natGatewayRuleProperties is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.depth != nil {
		localVarQueryParams.Add("depth", parameterToString(*r.depth, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xContractNumber != nil {
		localVarHeaderParams["X-Contract-Number"] = parameterToString(*r.xContractNumber, "")
	}
	// body params
	localVarPostBody = r.natGatewayRuleProperties
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Token Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)

	localVarAPIResponse := &APIResponse {
		Response: localVarHTTPResponse,
		Method: localVarHTTPMethod,
		RequestURL: localVarPath,
		Operation: "DatacentersNatgatewaysRulesPatch",
	}

	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarAPIResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

type ApiDatacentersNatgatewaysRulesPostRequest struct {
	ctx _context.Context
	ApiService *NATGatewaysApiService
	datacenterId string
	natGatewayId string
	natGatewayRule *NatGatewayRule
	pretty *bool
	depth *int32
	xContractNumber *int32
}

func (r ApiDatacentersNatgatewaysRulesPostRequest) NatGatewayRule(natGatewayRule NatGatewayRule) ApiDatacentersNatgatewaysRulesPostRequest {
	r.natGatewayRule = &natGatewayRule
	return r
}
func (r ApiDatacentersNatgatewaysRulesPostRequest) Pretty(pretty bool) ApiDatacentersNatgatewaysRulesPostRequest {
	r.pretty = &pretty
	return r
}
func (r ApiDatacentersNatgatewaysRulesPostRequest) Depth(depth int32) ApiDatacentersNatgatewaysRulesPostRequest {
	r.depth = &depth
	return r
}
func (r ApiDatacentersNatgatewaysRulesPostRequest) XContractNumber(xContractNumber int32) ApiDatacentersNatgatewaysRulesPostRequest {
	r.xContractNumber = &xContractNumber
	return r
}

func (r ApiDatacentersNatgatewaysRulesPostRequest) Execute() (NatGatewayRule, *APIResponse, error) {
	return r.ApiService.DatacentersNatgatewaysRulesPostExecute(r)
}

/*
 * DatacentersNatgatewaysRulesPost Create a NAT Gateway Rule
 * Creates a rule within the NAT Gateway of a datacenter.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param datacenterId The unique ID of the datacenter
 * @param natGatewayId The unique ID of the NAT gateway
 * @return ApiDatacentersNatgatewaysRulesPostRequest
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysRulesPost(ctx _context.Context, datacenterId string, natGatewayId string) ApiDatacentersNatgatewaysRulesPostRequest {
	return ApiDatacentersNatgatewaysRulesPostRequest{
		ApiService: a,
		ctx: ctx,
		datacenterId: datacenterId,
		natGatewayId: natGatewayId,
	}
}

/*
 * Execute executes the request
 * @return NatGatewayRule
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysRulesPostExecute(r ApiDatacentersNatgatewaysRulesPostRequest) (NatGatewayRule, *APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NatGatewayRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NATGatewaysApiService.DatacentersNatgatewaysRulesPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/datacenters/{datacenterId}/natgateways/{natGatewayId}/rules"
	localVarPath = strings.Replace(localVarPath, "{"+"datacenterId"+"}", _neturl.PathEscape(parameterToString(r.datacenterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"natGatewayId"+"}", _neturl.PathEscape(parameterToString(r.natGatewayId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.natGatewayRule == nil {
		return localVarReturnValue, nil, reportError("natGatewayRule is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.depth != nil {
		localVarQueryParams.Add("depth", parameterToString(*r.depth, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xContractNumber != nil {
		localVarHeaderParams["X-Contract-Number"] = parameterToString(*r.xContractNumber, "")
	}
	// body params
	localVarPostBody = r.natGatewayRule
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Token Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)

	localVarAPIResponse := &APIResponse {
		Response: localVarHTTPResponse,
		Method: localVarHTTPMethod,
		RequestURL: localVarPath,
		Operation: "DatacentersNatgatewaysRulesPost",
	}

	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarAPIResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

type ApiDatacentersNatgatewaysRulesPutRequest struct {
	ctx _context.Context
	ApiService *NATGatewaysApiService
	datacenterId string
	natGatewayId string
	natGatewayRuleId string
	natGatewayRule *NatGatewayRulePut
	pretty *bool
	depth *int32
	xContractNumber *int32
}

func (r ApiDatacentersNatgatewaysRulesPutRequest) NatGatewayRule(natGatewayRule NatGatewayRulePut) ApiDatacentersNatgatewaysRulesPutRequest {
	r.natGatewayRule = &natGatewayRule
	return r
}
func (r ApiDatacentersNatgatewaysRulesPutRequest) Pretty(pretty bool) ApiDatacentersNatgatewaysRulesPutRequest {
	r.pretty = &pretty
	return r
}
func (r ApiDatacentersNatgatewaysRulesPutRequest) Depth(depth int32) ApiDatacentersNatgatewaysRulesPutRequest {
	r.depth = &depth
	return r
}
func (r ApiDatacentersNatgatewaysRulesPutRequest) XContractNumber(xContractNumber int32) ApiDatacentersNatgatewaysRulesPutRequest {
	r.xContractNumber = &xContractNumber
	return r
}

func (r ApiDatacentersNatgatewaysRulesPutRequest) Execute() (NatGatewayRule, *APIResponse, error) {
	return r.ApiService.DatacentersNatgatewaysRulesPutExecute(r)
}

/*
 * DatacentersNatgatewaysRulesPut Modify a rule of the NAT gateway
 * You can use to update a rule of the NAT gateway.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param datacenterId The unique ID of the datacenter
 * @param natGatewayId The unique ID of the NAT gateway
 * @param natGatewayRuleId The unique ID of the NAT gateway rule
 * @return ApiDatacentersNatgatewaysRulesPutRequest
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysRulesPut(ctx _context.Context, datacenterId string, natGatewayId string, natGatewayRuleId string) ApiDatacentersNatgatewaysRulesPutRequest {
	return ApiDatacentersNatgatewaysRulesPutRequest{
		ApiService: a,
		ctx: ctx,
		datacenterId: datacenterId,
		natGatewayId: natGatewayId,
		natGatewayRuleId: natGatewayRuleId,
	}
}

/*
 * Execute executes the request
 * @return NatGatewayRule
 */
func (a *NATGatewaysApiService) DatacentersNatgatewaysRulesPutExecute(r ApiDatacentersNatgatewaysRulesPutRequest) (NatGatewayRule, *APIResponse, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NatGatewayRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NATGatewaysApiService.DatacentersNatgatewaysRulesPut")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/datacenters/{datacenterId}/natgateways/{natGatewayId}/rules/{natGatewayRuleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"datacenterId"+"}", _neturl.PathEscape(parameterToString(r.datacenterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"natGatewayId"+"}", _neturl.PathEscape(parameterToString(r.natGatewayId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"natGatewayRuleId"+"}", _neturl.PathEscape(parameterToString(r.natGatewayRuleId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.natGatewayRule == nil {
		return localVarReturnValue, nil, reportError("natGatewayRule is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.depth != nil {
		localVarQueryParams.Add("depth", parameterToString(*r.depth, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xContractNumber != nil {
		localVarHeaderParams["X-Contract-Number"] = parameterToString(*r.xContractNumber, "")
	}
	// body params
	localVarPostBody = r.natGatewayRule
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Token Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)

	localVarAPIResponse := &APIResponse {
		Response: localVarHTTPResponse,
		Method: localVarHTTPMethod,
		RequestURL: localVarPath,
		Operation: "DatacentersNatgatewaysRulesPut",
	}

	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarAPIResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}
