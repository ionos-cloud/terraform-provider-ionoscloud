/*
 * IONOS Object Storage API for contract-owned buckets
 *
 * ## Overview The IONOS Object Storage API for contract-owned buckets is a REST-based API that allows developers and applications to interact directly with IONOS' scalable storage solution, leveraging the S3 protocol for object storage operations. Its design ensures seamless compatibility with existing tools and libraries tailored for S3 systems.  ### API References - [S3 API Reference for contract-owned buckets](https://api.ionos.com/docs/s3-contract-owned-buckets/v2/) ### User documentation [IONOS Object Storage User Guide](https://docs.ionos.com/cloud/managed-services/s3-object-storage) * [Documentation on user-owned and contract-owned buckets](https://docs.ionos.com/cloud/managed-services/s3-object-storage/concepts/buckets) * [Documentation on S3 API Compatibility](https://docs.ionos.com/cloud/managed-services/s3-object-storage/concepts/s3-api-compatibility) * [S3 Tools](https://docs.ionos.com/cloud/managed-services/s3-object-storage/s3-tools)  ## Endpoints for contract-owned buckets | Location | Region Name | Bucket Type | Endpoint | | --- | --- | --- | --- | | **Berlin, Germany** | **eu-central-3** | Contract-owned | `https://s3.eu-central-3.ionoscloud.com` |  ## Changelog - 30.05.2024 Initial version
 *
 * API version: 2.0.2
 * Contact: support@cloud.ionos.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ionoscloud

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
	"time"

	"github.com/aws/aws-sdk-go/aws/credentials"
	awsv4 "github.com/aws/aws-sdk-go/aws/signer/v4"
)

const (
	IonosLogLevelEnvVar   = "IONOS_LOG_LEVEL"
	IonosApiUrlEnvVar     = "IONOS_API_URL"
	defaultMaxRetries     = 3
	defaultWaitTime       = time.Duration(100) * time.Millisecond
	defaultMaxWaitTime    = time.Duration(2000) * time.Millisecond
	DefaultIonosServerUrl = "https://s3.eu-central-3.ionoscloud.com"
	DefaultIonosBasePath  = ""
)

// contextKeys are used to identify the type of value in the context.
// Since these are string, it is possible to get a short description of the
// context key for logging and debugging using key.String().

type contextKey string

func (c contextKey) String() string {
	return "auth " + string(c)
}

var (
	// ContextAPIKeys takes a string apikey as authentication for the request
	ContextAPIKeys = contextKey("apiKeys")

	// ContextServerIndex uses a server configuration from the index.
	ContextServerIndex = contextKey("serverIndex")

	// ContextOperationServerIndices uses a server configuration from the index mapping.
	ContextOperationServerIndices = contextKey("serverOperationIndices")

	// ContextServerVariables overrides a server configuration variables.
	ContextServerVariables = contextKey("serverVariables")

	// ContextOperationServerVariables overrides a server configuration variables using operation specific values.
	ContextOperationServerVariables = contextKey("serverOperationVariables")
)

// BasicAuth provides basic http authentication to a request passed via context using ContextBasicAuth
type BasicAuth struct {
	UserName string `json:"userName,omitempty"`
	Password string `json:"password,omitempty"`
}

// APIKey provides API key based authentication to a request passed via context using ContextAPIKey
type APIKey struct {
	Key    string
	Prefix string
}

// ServerVariable stores the information about a server variable
type ServerVariable struct {
	Description  string
	DefaultValue string
	EnumValues   []string
}

// ServerConfiguration stores the information about a server
type ServerConfiguration struct {
	URL         string
	Description string
	Variables   map[string]ServerVariable
}

// ServerConfigurations stores multiple ServerConfiguration items
type ServerConfigurations []ServerConfiguration

// MiddlewareFunction provides way to implement custom middleware in the prepareRequest
type MiddlewareFunction func(*http.Request)

// MiddlewareFunctionWithError provides way to implement custom middleware with errors in the prepareRequest
type MiddlewareFunctionWithError func(*http.Request) error

// ResponseMiddlewareFunction provides way to implement custom middleware with errors after the response is received
type ResponseMiddlewareFunction func(*http.Response, []byte) error

// Configuration stores the configuration of the API client
type Configuration struct {
	Host                string            `json:"host,omitempty"`
	Scheme              string            `json:"scheme,omitempty"`
	DefaultHeader       map[string]string `json:"defaultHeader,omitempty"`
	UserAgent           string            `json:"userAgent,omitempty"`
	Debug               bool              `json:"debug,omitempty"`
	Servers             ServerConfigurations
	OperationServers    map[string]ServerConfigurations
	HTTPClient          *http.Client
	Middleware          MiddlewareFunction
	MiddlewareWithError MiddlewareFunctionWithError
	ResponseMiddleware  ResponseMiddlewareFunction
	MaxRetries          int           `json:"maxRetries,omitempty"`
	WaitTime            time.Duration `json:"waitTime,omitempty"`
	MaxWaitTime         time.Duration `json:"maxWaitTime,omitempty"`
	LogLevel            LogLevel
	Logger              Logger
}

// NewConfiguration returns a new Configuration object
func NewConfiguration(hostUrl string) *Configuration {
	cfg := &Configuration{
		DefaultHeader: make(map[string]string),
		UserAgent:     "ionos-cloud-sdk-go-object-storage/v1.1.0",
		Debug:         false,
		MaxRetries:    defaultMaxRetries,
		MaxWaitTime:   defaultMaxWaitTime,
		WaitTime:      defaultWaitTime,
		Logger:        NewDefaultLogger(),
		LogLevel:      getLogLevelFromEnv(),
		Host:          getHost(hostUrl),
		Scheme:        getScheme(hostUrl),
		Servers: ServerConfigurations{
			{
				URL:         getServerUrl(hostUrl),
				Description: "The endpoint for the `eu-central-3` region (Berlin, Germany)",
			},
		},
		OperationServers: map[string]ServerConfigurations{},
	}
	return cfg
}

func NewConfigurationFromEnv() *Configuration {
	region := "eu-central-3"
	service := "s3"
	cfg := NewConfiguration(os.Getenv(IonosApiUrlEnvVar))
	cfg.MiddlewareWithError = signerMw(region, service, os.Getenv("IONOS_S3_ACCESS_KEY"), os.Getenv("IONOS_S3_SECRET_KEY"))
	return cfg
}

// AddDefaultHeader adds a new HTTP header to the default header in the request
func (c *Configuration) AddDefaultHeader(key string, value string) {
	c.DefaultHeader[key] = value
}

// URL formats template on a index using given variables
func (sc ServerConfigurations) URL(index int, variables map[string]string) (string, error) {
	if index < 0 || len(sc) <= index {
		return "", fmt.Errorf("index %v out of range %v", index, len(sc)-1)
	}
	server := sc[index]
	url := server.URL

	// go through variables and replace placeholders
	for name, variable := range server.Variables {
		if value, ok := variables[name]; ok {
			found := bool(len(variable.EnumValues) == 0)
			for _, enumValue := range variable.EnumValues {
				if value == enumValue {
					found = true
				}
			}
			if !found {
				return "", fmt.Errorf("the variable %s in the server URL has invalid value %v. Must be %v", name, value, variable.EnumValues)
			}
			url = strings.Replace(url, "{"+name+"}", value, -1)
		} else {
			url = strings.Replace(url, "{"+name+"}", variable.DefaultValue, -1)
		}
	}
	return url, nil
}

// ServerURL returns URL based on server settings
func (c *Configuration) ServerURL(index int, variables map[string]string) (string, error) {
	return c.Servers.URL(index, variables)
}

func getServerIndex(ctx context.Context) (int, error) {
	si := ctx.Value(ContextServerIndex)
	if si != nil {
		if index, ok := si.(int); ok {
			return index, nil
		}
		return 0, reportError("Invalid type %T should be int", si)
	}
	return 0, nil
}

func getServerOperationIndex(ctx context.Context, endpoint string) (int, error) {
	osi := ctx.Value(ContextOperationServerIndices)
	if osi != nil {
		if operationIndices, ok := osi.(map[string]int); !ok {
			return 0, reportError("Invalid type %T should be map[string]int", osi)
		} else {
			index, ok := operationIndices[endpoint]
			if ok {
				return index, nil
			}
		}
	}
	return getServerIndex(ctx)
}

func getServerVariables(ctx context.Context) (map[string]string, error) {
	sv := ctx.Value(ContextServerVariables)
	if sv != nil {
		if variables, ok := sv.(map[string]string); ok {
			return variables, nil
		}
		return nil, reportError("ctx value of ContextServerVariables has invalid type %T should be map[string]string", sv)
	}
	return nil, nil
}

func getServerOperationVariables(ctx context.Context, endpoint string) (map[string]string, error) {
	osv := ctx.Value(ContextOperationServerVariables)
	if osv != nil {
		if operationVariables, ok := osv.(map[string]map[string]string); !ok {
			return nil, reportError("ctx value of ContextOperationServerVariables has invalid type %T should be map[string]map[string]string", osv)
		} else {
			variables, ok := operationVariables[endpoint]
			if ok {
				return variables, nil
			}
		}
	}
	return getServerVariables(ctx)
}

func getServerUrl(serverUrl string) string {
	if serverUrl == "" {
		return DefaultIonosServerUrl
	}
	if !strings.HasPrefix(serverUrl, "https://") && !strings.HasPrefix(serverUrl, "http://") {
		serverUrl = fmt.Sprintf("https://%s", serverUrl)
	}
	if !strings.HasSuffix(serverUrl, DefaultIonosBasePath) {
		serverUrl = fmt.Sprintf("%s%s", serverUrl, DefaultIonosBasePath)
	}
	return serverUrl
}

func getHost(serverUrl string) string {
	// url.Parse only interprets the host correctly when the scheme is set, so we prepend one here if needed
	if !strings.HasPrefix(serverUrl, "https://") && !strings.HasPrefix(serverUrl, "http://") {
		serverUrl = "http://" + serverUrl
	}
	url, err := url.Parse(serverUrl)
	if err != nil {
		return ""
	}
	return url.Host
}

func getScheme(serverUrl string) string {
	url, err := url.Parse(serverUrl)
	if err != nil {
		return ""
	}
	return url.Scheme
}

// ServerURLWithContext returns a new server URL given an endpoint
func (c *Configuration) ServerURLWithContext(ctx context.Context, endpoint string) (string, error) {
	sc, ok := c.OperationServers[endpoint]
	if !ok {
		sc = c.Servers
	}

	if ctx == nil {
		return sc.URL(0, nil)
	}

	index, err := getServerOperationIndex(ctx, endpoint)
	if err != nil {
		return "", err
	}

	variables, err := getServerOperationVariables(ctx, endpoint)
	if err != nil {
		return "", err
	}

	return sc.URL(index, variables)
}

func signerMw(region, service, accessKey, secretKey string) MiddlewareFunctionWithError {
	signer := awsv4.NewSigner(credentials.NewStaticCredentials(accessKey, secretKey, ""))

	// Define default values for region and service to maintain backward compatibility
	if region == "" {
		region = "eu-central-3"
	}
	if service == "" {
		service = "s3"
	}
	return func(r *http.Request) error {
		var reader io.ReadSeeker
		if r.Body != nil {
			bodyBytes, err := io.ReadAll(r.Body)
			if err != nil {
				return err
			}
			reader = bytes.NewReader(bodyBytes)
		}
		_, err := signer.Sign(r, reader, service, region, time.Now())
		return err
	}
}
