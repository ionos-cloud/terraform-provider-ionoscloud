/*
 * IONOS Object Storage API for contract-owned buckets
 *
 * ## Overview The IONOS Object Storage API for contract-owned buckets is a REST-based API that allows developers and applications to interact directly with IONOS' scalable storage solution, leveraging the S3 protocol for object storage operations. Its design ensures seamless compatibility with existing tools and libraries tailored for S3 systems.  ### API References - [S3 API Reference for contract-owned buckets](https://api.ionos.com/docs/s3-contract-owned-buckets/v2/) ### User documentation [IONOS Object Storage User Guide](https://docs.ionos.com/cloud/managed-services/s3-object-storage) * [Documentation on user-owned and contract-owned buckets](https://docs.ionos.com/cloud/managed-services/s3-object-storage/concepts/buckets) * [Documentation on S3 API Compatibility](https://docs.ionos.com/cloud/managed-services/s3-object-storage/concepts/s3-api-compatibility) * [S3 Tools](https://docs.ionos.com/cloud/managed-services/s3-object-storage/s3-tools)  ## Endpoints for contract-owned buckets | Location | Region Name | Bucket Type | Endpoint | | --- | --- | --- | --- | | **Berlin, Germany** | **eu-central-3** | Contract-owned | `https://s3.eu-central-3.ionoscloud.com` |  ## Changelog - 30.05.2024 Initial version
 *
 * API version: 2.0.2
 * Contact: support@cloud.ionos.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ionoscloud

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// UploadsApiService UploadsApi service
type UploadsApiService service

type ApiAbortMultipartUploadRequest struct {
	ctx        context.Context
	ApiService *UploadsApiService
	bucket     string
	key        string
	uploadId   *string
}

// Upload ID that identifies the multipart upload.
func (r ApiAbortMultipartUploadRequest) UploadId(uploadId string) ApiAbortMultipartUploadRequest {
	r.uploadId = &uploadId
	return r
}

func (r ApiAbortMultipartUploadRequest) Execute() (map[string]interface{}, *APIResponse, error) {
	return r.ApiService.AbortMultipartUploadExecute(r)
}

/*
AbortMultipartUpload AbortMultipartUpload

<p>This operation aborts a multipart upload. After a multipart upload is aborted, no additional parts can be uploaded using that upload ID. The storage consumed by any previously uploaded parts will be freed. However, if any part uploads are currently in progress, those part uploads might or might not succeed. As a result, it might be necessary to abort a given multipart upload multiple times in order to completely free all storage consumed by all parts. </p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param bucket
	@param key Key of the object for which the multipart upload was initiated. <p> **Possible values:** length â‰¥ 1 </p>
	@return ApiAbortMultipartUploadRequest
*/
func (a *UploadsApiService) AbortMultipartUpload(ctx context.Context, bucket string, key string) ApiAbortMultipartUploadRequest {
	return ApiAbortMultipartUploadRequest{
		ApiService: a,
		ctx:        ctx,
		bucket:     bucket,
		key:        key,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *UploadsApiService) AbortMultipartUploadExecute(r ApiAbortMultipartUploadRequest) (map[string]interface{}, *APIResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UploadsApiService.AbortMultipartUpload")
	if err != nil {
		gerr := GenericOpenAPIError{}
		gerr.SetError(err.Error())
		return localVarReturnValue, nil, gerr
	}

	localVarPath := localBasePath + "/{Bucket}/{Key}?uploadId"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", parameterValueToString(r.bucket, "bucket"), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Key"+"}", parameterValueToString(r.key, "key"), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if Strlen(r.bucket) < 3 {
		return localVarReturnValue, nil, reportError("bucket must have at least 3 elements")
	}
	if Strlen(r.bucket) > 63 {
		return localVarReturnValue, nil, reportError("bucket must have less than 63 elements")
	}
	if Strlen(r.key) < 1 {
		return localVarReturnValue, nil, reportError("key must have at least 1 elements")
	}
	if r.uploadId == nil {
		return localVarReturnValue, nil, reportError("uploadId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "uploadId", r.uploadId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/xml", "aplication/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, httpRequestTime, err := a.client.callAPI(req)
	localVarAPIResponse := &APIResponse{
		Response:    localVarHTTPResponse,
		Method:      localVarHTTPMethod,
		RequestTime: httpRequestTime,
		RequestURL:  localVarPath,
		Operation:   "AbortMultipartUpload",
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{}
		newErr.SetStatusCode(localVarHTTPResponse.StatusCode)
		newErr.SetBody(localVarBody)
		newErr.SetError(fmt.Sprintf("%s: %s", localVarHTTPResponse.Status, string(localVarBody)))
		if localVarHTTPResponse.StatusCode == 480 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.SetError(err.Error())
				return localVarReturnValue, localVarAPIResponse, newErr
			}
			newErr.SetModel(v)
		}
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{}
		newErr.SetStatusCode(localVarHTTPResponse.StatusCode)
		newErr.SetBody(localVarBody)
		newErr.SetError(err.Error())
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

type ApiCompleteMultipartUploadRequest struct {
	ctx        context.Context
	ApiService *UploadsApiService
	bucket     string
	key        string
	uploadId   *string
	example    *Example
}

// ID for the initiated multipart upload.
func (r ApiCompleteMultipartUploadRequest) UploadId(uploadId string) ApiCompleteMultipartUploadRequest {
	r.uploadId = &uploadId
	return r
}

func (r ApiCompleteMultipartUploadRequest) Example(example Example) ApiCompleteMultipartUploadRequest {
	r.example = &example
	return r
}

func (r ApiCompleteMultipartUploadRequest) Execute() (*CompleteMultipartUploadOutput, *APIResponse, error) {
	return r.ApiService.CompleteMultipartUploadExecute(r)
}

/*
CompleteMultipartUpload CompleteMultipartUpload

<p>Completes a multipart upload by assembling previously uploaded parts.</p>          <p>After successfully uploading all relevant parts of an upload, you call this operation to complete the upload. When IONOS Object Storage  receives this request,  it concatenates all the parts in ascending  order by part number to create a new object. The parts  list must be included in the Complete Multipart Upload request. You must ensure that the parts list is complete. This operation concatenates the parts that you provide in the list. For each part in the list, you must provide the part number and the `ETag` value, returned after that part was uploaded.</p> <p>A Complete Multipart Upload request could take several minutes to process.  After IONOS Object Storage begins processing the request, it sends  an HTTP response header indicating a 200 OK response. While processing is  in progress, IONOS Object Storage sends white space characters  on a regular basis to keep the connection from timing out. Because a request  may fail after receiving the initial 200 OK response, it is advisable to  check the response body to establish whether the request was successful.</p>  <p> `CompleteMultipartUpload` has the following special errors:</p> <ul> <li> <p>Error code: `EntityTooSmall` </p> <ul> <li> <p>Description: Your proposed upload is smaller than the minimum allowed object size. Each part must be at least 5 MB in size, except the last part.</p> </li> <li> <p>400 Bad Request</p> </li> </ul> </li> <li> <p>Error code: `InvalidPart` </p> <ul> <li> <p>Description: One or more of the specified parts could not be found. The part might not have been uploaded, or the specified entity tag might not have matched the part's entity tag.</p> </li> <li> <p>400 Bad Request</p> </li> </ul> </li> <li> <p>Error code: `InvalidPartOrder` </p> <ul> <li> <p>Description: The list of parts was not in ascending order. The parts list must be specified in order by part number.</p> </li> <li> <p>400 Bad Request</p> </li> </ul> </li> <li> <p>Error code: `NoSuchUpload` </p> <ul> <li> <p>Description: The specified multipart upload does not exist. The upload ID might be invalid, or the multipart upload might have been aborted or completed.</p> </li> <li> <p>404 Not Found</p> </li> </ul> </li> </ul>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param bucket
	@param key Object key for which the multipart upload was initiated.
	@return ApiCompleteMultipartUploadRequest
*/
func (a *UploadsApiService) CompleteMultipartUpload(ctx context.Context, bucket string, key string) ApiCompleteMultipartUploadRequest {
	return ApiCompleteMultipartUploadRequest{
		ApiService: a,
		ctx:        ctx,
		bucket:     bucket,
		key:        key,
	}
}

// Execute executes the request
//
//	@return CompleteMultipartUploadOutput
func (a *UploadsApiService) CompleteMultipartUploadExecute(r ApiCompleteMultipartUploadRequest) (*CompleteMultipartUploadOutput, *APIResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CompleteMultipartUploadOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UploadsApiService.CompleteMultipartUpload")
	if err != nil {
		gerr := GenericOpenAPIError{}
		gerr.SetError(err.Error())
		return localVarReturnValue, nil, gerr
	}

	localVarPath := localBasePath + "/{Bucket}/{Key}?uploadId"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", parameterValueToString(r.bucket, "bucket"), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Key"+"}", parameterValueToString(r.key, "key"), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if Strlen(r.bucket) < 3 {
		return localVarReturnValue, nil, reportError("bucket must have at least 3 elements")
	}
	if Strlen(r.bucket) > 63 {
		return localVarReturnValue, nil, reportError("bucket must have less than 63 elements")
	}
	if Strlen(r.key) < 1 {
		return localVarReturnValue, nil, reportError("key must have at least 1 elements")
	}
	if r.uploadId == nil {
		return localVarReturnValue, nil, reportError("uploadId is required and must be specified")
	}
	if r.example == nil {
		return localVarReturnValue, nil, reportError("example is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "uploadId", r.uploadId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.example
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, httpRequestTime, err := a.client.callAPI(req)
	localVarAPIResponse := &APIResponse{
		Response:    localVarHTTPResponse,
		Method:      localVarHTTPMethod,
		RequestTime: httpRequestTime,
		RequestURL:  localVarPath,
		Operation:   "CompleteMultipartUpload",
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{}
		newErr.SetStatusCode(localVarHTTPResponse.StatusCode)
		newErr.SetBody(localVarBody)
		newErr.SetError(fmt.Sprintf("%s: %s", localVarHTTPResponse.Status, string(localVarBody)))
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{}
		newErr.SetStatusCode(localVarHTTPResponse.StatusCode)
		newErr.SetBody(localVarBody)
		newErr.SetError(err.Error())
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

type ApiCreateMultipartUploadRequest struct {
	ctx                                       context.Context
	ApiService                                *UploadsApiService
	bucket                                    string
	key                                       string
	uploads                                   *bool
	cacheControl                              *string
	contentDisposition                        *string
	contentEncoding                           *string
	contentType                               *string
	expires                                   *time.Time
	xAmzServerSideEncryption                  *string
	xAmzStorageClass                          *string
	xAmzWebsiteRedirectLocation               *string
	xAmzServerSideEncryptionCustomerAlgorithm *string
	xAmzServerSideEncryptionCustomerKey       *string
	xAmzServerSideEncryptionCustomerKeyMD5    *string
	xAmzObjectLockMode                        *string
	xAmzObjectLockRetainUntilDate             *time.Time
	xAmzObjectLockLegalHold                   *string
	xAmzMeta                                  *map[string]string
}

func (r ApiCreateMultipartUploadRequest) Uploads(uploads bool) ApiCreateMultipartUploadRequest {
	r.uploads = &uploads
	return r
}

// Specifies caching behavior along the request/reply chain.
func (r ApiCreateMultipartUploadRequest) CacheControl(cacheControl string) ApiCreateMultipartUploadRequest {
	r.cacheControl = &cacheControl
	return r
}

// Specifies presentational information for the object.
func (r ApiCreateMultipartUploadRequest) ContentDisposition(contentDisposition string) ApiCreateMultipartUploadRequest {
	r.contentDisposition = &contentDisposition
	return r
}

// Specifies what content encodings have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field.
func (r ApiCreateMultipartUploadRequest) ContentEncoding(contentEncoding string) ApiCreateMultipartUploadRequest {
	r.contentEncoding = &contentEncoding
	return r
}

// A standard MIME type describing the format of the object data.
func (r ApiCreateMultipartUploadRequest) ContentType(contentType string) ApiCreateMultipartUploadRequest {
	r.contentType = &contentType
	return r
}

// The date and time at which the object is no longer cacheable.
func (r ApiCreateMultipartUploadRequest) Expires(expires time.Time) ApiCreateMultipartUploadRequest {
	r.expires = &expires
	return r
}

// The server-side encryption algorithm used when storing this object in IONOS Object Storage (AES256).
func (r ApiCreateMultipartUploadRequest) XAmzServerSideEncryption(xAmzServerSideEncryption string) ApiCreateMultipartUploadRequest {
	r.xAmzServerSideEncryption = &xAmzServerSideEncryption
	return r
}

// IONOS Object Storage uses the STANDARD Storage Class to store newly created objects. The STANDARD storage class provides high durability and high availability.
func (r ApiCreateMultipartUploadRequest) XAmzStorageClass(xAmzStorageClass string) ApiCreateMultipartUploadRequest {
	r.xAmzStorageClass = &xAmzStorageClass
	return r
}

// If the bucket is configured as a website, redirects requests for this object to another object in the same bucket or to an external URL. IONOS Object Storage stores the value of this header in the object metadata.
func (r ApiCreateMultipartUploadRequest) XAmzWebsiteRedirectLocation(xAmzWebsiteRedirectLocation string) ApiCreateMultipartUploadRequest {
	r.xAmzWebsiteRedirectLocation = &xAmzWebsiteRedirectLocation
	return r
}

// Specifies the algorithm to use to when encrypting the object (AES256).
func (r ApiCreateMultipartUploadRequest) XAmzServerSideEncryptionCustomerAlgorithm(xAmzServerSideEncryptionCustomerAlgorithm string) ApiCreateMultipartUploadRequest {
	r.xAmzServerSideEncryptionCustomerAlgorithm = &xAmzServerSideEncryptionCustomerAlgorithm
	return r
}

// Specifies the customer-provided encryption key for IONOS Object Storage to use in encrypting data. This value is used to store the object and then it is discarded; IONOS Object Storage does not store the encryption key. The key must be appropriate for use with the algorithm specified in the &#x60;x-amz-server-side-encryption-customer-algorithm&#x60; header.
func (r ApiCreateMultipartUploadRequest) XAmzServerSideEncryptionCustomerKey(xAmzServerSideEncryptionCustomerKey string) ApiCreateMultipartUploadRequest {
	r.xAmzServerSideEncryptionCustomerKey = &xAmzServerSideEncryptionCustomerKey
	return r
}

// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. IONOS Object Storage uses this header for a message integrity check to ensure that the encryption key was transmitted without error.
func (r ApiCreateMultipartUploadRequest) XAmzServerSideEncryptionCustomerKeyMD5(xAmzServerSideEncryptionCustomerKeyMD5 string) ApiCreateMultipartUploadRequest {
	r.xAmzServerSideEncryptionCustomerKeyMD5 = &xAmzServerSideEncryptionCustomerKeyMD5
	return r
}

// Specifies the Object Lock mode that you want to apply to the uploaded object.
func (r ApiCreateMultipartUploadRequest) XAmzObjectLockMode(xAmzObjectLockMode string) ApiCreateMultipartUploadRequest {
	r.xAmzObjectLockMode = &xAmzObjectLockMode
	return r
}

// Specifies the date and time when you want the Object Lock to expire.
func (r ApiCreateMultipartUploadRequest) XAmzObjectLockRetainUntilDate(xAmzObjectLockRetainUntilDate time.Time) ApiCreateMultipartUploadRequest {
	r.xAmzObjectLockRetainUntilDate = &xAmzObjectLockRetainUntilDate
	return r
}

// Specifies whether you want to apply a Legal Hold to the uploaded object.
func (r ApiCreateMultipartUploadRequest) XAmzObjectLockLegalHold(xAmzObjectLockLegalHold string) ApiCreateMultipartUploadRequest {
	r.xAmzObjectLockLegalHold = &xAmzObjectLockLegalHold
	return r
}

// A map of metadata to store with the object in S3.
func (r ApiCreateMultipartUploadRequest) XAmzMeta(xAmzMeta map[string]string) ApiCreateMultipartUploadRequest {
	r.xAmzMeta = &xAmzMeta
	return r
}

func (r ApiCreateMultipartUploadRequest) Execute() (*CreateMultipartUploadOutput, *APIResponse, error) {
	return r.ApiService.CreateMultipartUploadExecute(r)
}

/*
CreateMultipartUpload CreateMultipartUpload

<p>This operation initiates a multipart upload and returns an upload ID. This upload ID is used to associate all of the parts in the specific multipart upload. You specify this upload ID in each of your subsequent upload part requests. You also include this upload ID in the final request to either complete or abort the multipart upload request.</p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param bucket
	@param key Object key for which the multipart upload is to be initiated.
	@return ApiCreateMultipartUploadRequest
*/
func (a *UploadsApiService) CreateMultipartUpload(ctx context.Context, bucket string, key string) ApiCreateMultipartUploadRequest {
	return ApiCreateMultipartUploadRequest{
		ApiService: a,
		ctx:        ctx,
		bucket:     bucket,
		key:        key,
	}
}

// Execute executes the request
//
//	@return CreateMultipartUploadOutput
func (a *UploadsApiService) CreateMultipartUploadExecute(r ApiCreateMultipartUploadRequest) (*CreateMultipartUploadOutput, *APIResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreateMultipartUploadOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UploadsApiService.CreateMultipartUpload")
	if err != nil {
		gerr := GenericOpenAPIError{}
		gerr.SetError(err.Error())
		return localVarReturnValue, nil, gerr
	}

	localVarPath := localBasePath + "/{Bucket}/{Key}?uploads"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", parameterValueToString(r.bucket, "bucket"), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Key"+"}", parameterValueToString(r.key, "key"), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if Strlen(r.bucket) < 3 {
		return localVarReturnValue, nil, reportError("bucket must have at least 3 elements")
	}
	if Strlen(r.bucket) > 63 {
		return localVarReturnValue, nil, reportError("bucket must have less than 63 elements")
	}
	if Strlen(r.key) < 1 {
		return localVarReturnValue, nil, reportError("key must have at least 1 elements")
	}
	if r.uploads == nil {
		return localVarReturnValue, nil, reportError("uploads is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "uploads", r.uploads, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.cacheControl != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Cache-Control", r.cacheControl, "")
	}
	if r.contentDisposition != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Disposition", r.contentDisposition, "")
	}
	if r.contentEncoding != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Encoding", r.contentEncoding, "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
	}
	if r.expires != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Expires", r.expires, "")
	}
	if r.xAmzServerSideEncryption != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption", r.xAmzServerSideEncryption, "")
	}
	if r.xAmzStorageClass != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-storage-class", r.xAmzStorageClass, "")
	}
	if r.xAmzWebsiteRedirectLocation != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-website-redirect-location", r.xAmzWebsiteRedirectLocation, "")
	}
	if r.xAmzServerSideEncryptionCustomerAlgorithm != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-customer-algorithm", r.xAmzServerSideEncryptionCustomerAlgorithm, "")
	}
	if r.xAmzServerSideEncryptionCustomerKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-customer-key", r.xAmzServerSideEncryptionCustomerKey, "")
	}
	if r.xAmzServerSideEncryptionCustomerKeyMD5 != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-customer-key-MD5", r.xAmzServerSideEncryptionCustomerKeyMD5, "")
	}
	if r.xAmzObjectLockMode != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-object-lock-mode", r.xAmzObjectLockMode, "")
	}
	if r.xAmzObjectLockRetainUntilDate != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-object-lock-retain-until-date", r.xAmzObjectLockRetainUntilDate, "")
	}
	if r.xAmzObjectLockLegalHold != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-object-lock-legal-hold", r.xAmzObjectLockLegalHold, "")
	}
	if r.xAmzMeta != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-meta", r.xAmzMeta, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, httpRequestTime, err := a.client.callAPI(req)
	localVarAPIResponse := &APIResponse{
		Response:    localVarHTTPResponse,
		Method:      localVarHTTPMethod,
		RequestTime: httpRequestTime,
		RequestURL:  localVarPath,
		Operation:   "CreateMultipartUpload",
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{}
		newErr.SetStatusCode(localVarHTTPResponse.StatusCode)
		newErr.SetBody(localVarBody)
		newErr.SetError(fmt.Sprintf("%s: %s", localVarHTTPResponse.Status, string(localVarBody)))
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{}
		newErr.SetStatusCode(localVarHTTPResponse.StatusCode)
		newErr.SetBody(localVarBody)
		newErr.SetError(err.Error())
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

type ApiListMultipartUploadsRequest struct {
	ctx             context.Context
	ApiService      *UploadsApiService
	bucket          string
	uploads         *bool
	delimiter       *string
	encodingType    *string
	keyMarker       *string
	maxUploads      *int32
	prefix          *string
	uploadIdMarker  *string
	maxUploads2     *string
	keyMarker2      *string
	uploadIdMarker2 *string
}

func (r ApiListMultipartUploadsRequest) Uploads(uploads bool) ApiListMultipartUploadsRequest {
	r.uploads = &uploads
	return r
}

// &lt;p&gt;Character you use to group keys.&lt;/p&gt; &lt;p&gt;All keys that contain the same string between the prefix, if specified, and the first occurrence of the delimiter after the prefix are grouped under a single result element, &#x60;CommonPrefixes&#x60;. If you don&#39;t specify the prefix parameter, then the substring starts at the beginning of the key. The keys that are grouped under &#x60;CommonPrefixes&#x60; result element are not returned elsewhere in the response.&lt;/p&gt;
func (r ApiListMultipartUploadsRequest) Delimiter(delimiter string) ApiListMultipartUploadsRequest {
	r.delimiter = &delimiter
	return r
}

func (r ApiListMultipartUploadsRequest) EncodingType(encodingType string) ApiListMultipartUploadsRequest {
	r.encodingType = &encodingType
	return r
}

// &lt;p&gt;Together with upload-id-marker, this parameter specifies the multipart upload after which listing should begin.&lt;/p&gt; &lt;p&gt;If &#x60;upload-id-marker&#x60; is not specified, only the keys lexicographically greater than the specified &#x60;key-marker&#x60; will be included in the list.&lt;/p&gt; &lt;p&gt;If &#x60;upload-id-marker&#x60; is specified, any multipart uploads for a key equal to the &#x60;key-marker&#x60; might also be included, provided those multipart uploads have upload IDs lexicographically greater than the specified &#x60;upload-id-marker&#x60;.&lt;/p&gt;
func (r ApiListMultipartUploadsRequest) KeyMarker(keyMarker string) ApiListMultipartUploadsRequest {
	r.keyMarker = &keyMarker
	return r
}

// Sets the maximum number of multipart uploads, from 1 to 1,000, to return in the response body. 1,000 is the maximum number of uploads that can be returned in a response.
func (r ApiListMultipartUploadsRequest) MaxUploads(maxUploads int32) ApiListMultipartUploadsRequest {
	r.maxUploads = &maxUploads
	return r
}

// Lists in-progress uploads only for those keys that begin with the specified prefix. You can use prefixes to separate a bucket into different grouping of keys. (You can think of using prefix to make groups in the same way you&#39;d use a folder in a file system.)
func (r ApiListMultipartUploadsRequest) Prefix(prefix string) ApiListMultipartUploadsRequest {
	r.prefix = &prefix
	return r
}

// Together with key-marker, specifies the multipart upload after which listing should begin. If key-marker is not specified, the upload-id-marker parameter is ignored. Otherwise, any multipart uploads for a key equal to the key-marker might be included in the list only if they have an upload ID lexicographically greater than the specified &#x60;upload-id-marker&#x60;.
func (r ApiListMultipartUploadsRequest) UploadIdMarker(uploadIdMarker string) ApiListMultipartUploadsRequest {
	r.uploadIdMarker = &uploadIdMarker
	return r
}

// Pagination limit
func (r ApiListMultipartUploadsRequest) MaxUploads2(maxUploads2 string) ApiListMultipartUploadsRequest {
	r.maxUploads2 = &maxUploads2
	return r
}

// Pagination token
func (r ApiListMultipartUploadsRequest) KeyMarker2(keyMarker2 string) ApiListMultipartUploadsRequest {
	r.keyMarker2 = &keyMarker2
	return r
}

// Pagination token
func (r ApiListMultipartUploadsRequest) UploadIdMarker2(uploadIdMarker2 string) ApiListMultipartUploadsRequest {
	r.uploadIdMarker2 = &uploadIdMarker2
	return r
}

func (r ApiListMultipartUploadsRequest) Execute() (*ListMultipartUploadsOutput, *APIResponse, error) {
	return r.ApiService.ListMultipartUploadsExecute(r)
}

/*
ListMultipartUploads ListMultipartUploads

<p>This operation lists in-progress multipart uploads. An in-progress multipart upload is a multipart upload that has been initiated using the Initiate Multipart Upload request, but has not yet been completed or aborted.</p> <p>This operation returns at most 1,000 multipart uploads in the response. 1,000 multipart uploads is the maximum number of uploads a response can include, which is also the default value. You can further limit the number of uploads in a response by specifying the `max-uploads` parameter in the response. If additional multipart uploads satisfy the list criteria, the response will contain an `IsTruncated` element with the value true. To list the additional multipart uploads, use the `key-marker` and `upload-id-marker` request parameters.</p> <p>In the response, the uploads are sorted by key. If your application has initiated more than one multipart upload using the same object key, then uploads in the response are first sorted by key. Additionally, uploads are sorted in ascending order within each key by the upload initiation time.</p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param bucket
	@return ApiListMultipartUploadsRequest
*/
func (a *UploadsApiService) ListMultipartUploads(ctx context.Context, bucket string) ApiListMultipartUploadsRequest {
	return ApiListMultipartUploadsRequest{
		ApiService: a,
		ctx:        ctx,
		bucket:     bucket,
	}
}

// Execute executes the request
//
//	@return ListMultipartUploadsOutput
func (a *UploadsApiService) ListMultipartUploadsExecute(r ApiListMultipartUploadsRequest) (*ListMultipartUploadsOutput, *APIResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListMultipartUploadsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UploadsApiService.ListMultipartUploads")
	if err != nil {
		gerr := GenericOpenAPIError{}
		gerr.SetError(err.Error())
		return localVarReturnValue, nil, gerr
	}

	localVarPath := localBasePath + "/{Bucket}?uploads"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", parameterValueToString(r.bucket, "bucket"), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if Strlen(r.bucket) < 3 {
		return localVarReturnValue, nil, reportError("bucket must have at least 3 elements")
	}
	if Strlen(r.bucket) > 63 {
		return localVarReturnValue, nil, reportError("bucket must have less than 63 elements")
	}
	if r.uploads == nil {
		return localVarReturnValue, nil, reportError("uploads is required and must be specified")
	}

	if r.delimiter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delimiter", r.delimiter, "")
	}
	if r.encodingType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "encoding-type", r.encodingType, "")
	}
	if r.keyMarker != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key-marker", r.keyMarker, "")
	}
	if r.maxUploads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-uploads", r.maxUploads, "")
	}
	if r.prefix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", r.prefix, "")
	}
	if r.uploadIdMarker != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "upload-id-marker", r.uploadIdMarker, "")
	}
	if r.maxUploads2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "MaxUploads", r.maxUploads2, "")
	}
	if r.keyMarker2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "KeyMarker", r.keyMarker2, "")
	}
	if r.uploadIdMarker2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UploadIdMarker", r.uploadIdMarker2, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "uploads", r.uploads, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, httpRequestTime, err := a.client.callAPI(req)
	localVarAPIResponse := &APIResponse{
		Response:    localVarHTTPResponse,
		Method:      localVarHTTPMethod,
		RequestTime: httpRequestTime,
		RequestURL:  localVarPath,
		Operation:   "ListMultipartUploads",
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{}
		newErr.SetStatusCode(localVarHTTPResponse.StatusCode)
		newErr.SetBody(localVarBody)
		newErr.SetError(fmt.Sprintf("%s: %s", localVarHTTPResponse.Status, string(localVarBody)))
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{}
		newErr.SetStatusCode(localVarHTTPResponse.StatusCode)
		newErr.SetBody(localVarBody)
		newErr.SetError(err.Error())
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

type ApiListPartsRequest struct {
	ctx               context.Context
	ApiService        *UploadsApiService
	bucket            string
	key               string
	uploadId          *string
	maxParts          *int32
	partNumberMarker  *int32
	partNumberMarker2 *string
}

// Upload ID identifying the multipart upload whose parts are being listed.
func (r ApiListPartsRequest) UploadId(uploadId string) ApiListPartsRequest {
	r.uploadId = &uploadId
	return r
}

// Sets the maximum number of parts to return.
func (r ApiListPartsRequest) MaxParts(maxParts int32) ApiListPartsRequest {
	r.maxParts = &maxParts
	return r
}

// Specifies the part after which listing should begin. Only parts with higher part numbers will be listed.
func (r ApiListPartsRequest) PartNumberMarker(partNumberMarker int32) ApiListPartsRequest {
	r.partNumberMarker = &partNumberMarker
	return r
}

// Pagination token
func (r ApiListPartsRequest) PartNumberMarker2(partNumberMarker2 string) ApiListPartsRequest {
	r.partNumberMarker2 = &partNumberMarker2
	return r
}

func (r ApiListPartsRequest) Execute() (*ListPartsOutput, *APIResponse, error) {
	return r.ApiService.ListPartsExecute(r)
}

/*
ListParts ListParts

<p>Lists the parts that have been uploaded for a specific multipart upload. This operation must include the upload ID, which you obtain by sending the initiate multipart upload request. This request returns a maximum of 1,000 uploaded parts. The default number of parts returned is 1,000 parts. You can restrict the number of parts returned by specifying the `max-parts` request parameter. If your multipart upload consists of more than 1,000 parts, the response returns an `IsTruncated` field with the value of true, and a `NextPartNumberMarker` element. In subsequent `ListParts` requests you can include the part-number-marker query string parameter and set its value to the `NextPartNumberMarker` field value from the previous response.</p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param bucket
	@param key Object key for which the multipart upload was initiated.
	@return ApiListPartsRequest
*/
func (a *UploadsApiService) ListParts(ctx context.Context, bucket string, key string) ApiListPartsRequest {
	return ApiListPartsRequest{
		ApiService: a,
		ctx:        ctx,
		bucket:     bucket,
		key:        key,
	}
}

// Execute executes the request
//
//	@return ListPartsOutput
func (a *UploadsApiService) ListPartsExecute(r ApiListPartsRequest) (*ListPartsOutput, *APIResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListPartsOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UploadsApiService.ListParts")
	if err != nil {
		gerr := GenericOpenAPIError{}
		gerr.SetError(err.Error())
		return localVarReturnValue, nil, gerr
	}

	localVarPath := localBasePath + "/{Bucket}/{Key}?uploadId"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", parameterValueToString(r.bucket, "bucket"), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Key"+"}", parameterValueToString(r.key, "key"), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if Strlen(r.bucket) < 3 {
		return localVarReturnValue, nil, reportError("bucket must have at least 3 elements")
	}
	if Strlen(r.bucket) > 63 {
		return localVarReturnValue, nil, reportError("bucket must have less than 63 elements")
	}
	if Strlen(r.key) < 1 {
		return localVarReturnValue, nil, reportError("key must have at least 1 elements")
	}
	if r.uploadId == nil {
		return localVarReturnValue, nil, reportError("uploadId is required and must be specified")
	}

	if r.maxParts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max-parts", r.maxParts, "")
	}
	if r.partNumberMarker != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "part-number-marker", r.partNumberMarker, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "uploadId", r.uploadId, "")
	if r.partNumberMarker2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PartNumberMarker", r.partNumberMarker2, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, httpRequestTime, err := a.client.callAPI(req)
	localVarAPIResponse := &APIResponse{
		Response:    localVarHTTPResponse,
		Method:      localVarHTTPMethod,
		RequestTime: httpRequestTime,
		RequestURL:  localVarPath,
		Operation:   "ListParts",
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{}
		newErr.SetStatusCode(localVarHTTPResponse.StatusCode)
		newErr.SetBody(localVarBody)
		newErr.SetError(fmt.Sprintf("%s: %s", localVarHTTPResponse.Status, string(localVarBody)))
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{}
		newErr.SetStatusCode(localVarHTTPResponse.StatusCode)
		newErr.SetBody(localVarBody)
		newErr.SetError(err.Error())
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

type ApiUploadPartRequest struct {
	ctx                                       context.Context
	ApiService                                *UploadsApiService
	bucket                                    string
	key                                       string
	partNumber                                *int32
	uploadId                                  *string
	uploadPartRequest                         *UploadPartRequest
	contentLength                             *int32
	contentMD5                                *string
	xAmzServerSideEncryptionCustomerAlgorithm *string
	xAmzServerSideEncryptionCustomerKey       *string
	xAmzServerSideEncryptionCustomerKeyMD5    *string
}

// Part number of part being uploaded. This is a positive integer between 1 and 10,000.
func (r ApiUploadPartRequest) PartNumber(partNumber int32) ApiUploadPartRequest {
	r.partNumber = &partNumber
	return r
}

// Upload ID identifying the multipart upload whose part is being uploaded.
func (r ApiUploadPartRequest) UploadId(uploadId string) ApiUploadPartRequest {
	r.uploadId = &uploadId
	return r
}

func (r ApiUploadPartRequest) UploadPartRequest(uploadPartRequest UploadPartRequest) ApiUploadPartRequest {
	r.uploadPartRequest = &uploadPartRequest
	return r
}

// Size of the body in bytes. This parameter is useful when the size of the body cannot be determined automatically.
func (r ApiUploadPartRequest) ContentLength(contentLength int32) ApiUploadPartRequest {
	r.contentLength = &contentLength
	return r
}

func (r ApiUploadPartRequest) ContentMD5(contentMD5 string) ApiUploadPartRequest {
	r.contentMD5 = &contentMD5
	return r
}

// Specifies the algorithm to use to when encrypting the object (AES256).
func (r ApiUploadPartRequest) XAmzServerSideEncryptionCustomerAlgorithm(xAmzServerSideEncryptionCustomerAlgorithm string) ApiUploadPartRequest {
	r.xAmzServerSideEncryptionCustomerAlgorithm = &xAmzServerSideEncryptionCustomerAlgorithm
	return r
}

// Specifies the customer-provided encryption key for IONOS Object Storage to use in encrypting data. This value is used to store the object and then it is discarded; IONOS Object Storage does not store the encryption key. The key must be appropriate for use with the algorithm specified in the &#x60;x-amz-server-side-encryption-customer-algorithm header&#x60;. This must be the same encryption key specified in the initiate multipart upload request.
func (r ApiUploadPartRequest) XAmzServerSideEncryptionCustomerKey(xAmzServerSideEncryptionCustomerKey string) ApiUploadPartRequest {
	r.xAmzServerSideEncryptionCustomerKey = &xAmzServerSideEncryptionCustomerKey
	return r
}

// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. IONOS Object Storage uses this header for a message integrity check to ensure that the encryption key was transmitted without error.
func (r ApiUploadPartRequest) XAmzServerSideEncryptionCustomerKeyMD5(xAmzServerSideEncryptionCustomerKeyMD5 string) ApiUploadPartRequest {
	r.xAmzServerSideEncryptionCustomerKeyMD5 = &xAmzServerSideEncryptionCustomerKeyMD5
	return r
}

func (r ApiUploadPartRequest) Execute() (map[string]interface{}, *APIResponse, error) {
	return r.ApiService.UploadPartExecute(r)
}

/*
UploadPart UploadPart

<p>Uploads a part in a multipart upload.</p> <note> <p>In this operation, you provide part data in your request. However, you have an option to specify your existing IONOS Object Storage object as a data source for the part you are uploading. To upload a part from an existing object, you use the `UploadPartCopy` operation. </p> </note> <p>You must initiate a multipart upload (see `CreateMultipartUpload`) before you can upload any part. In response to your initiate request, IONOS Object Storage returns an upload ID, a unique identifier, that you must include in your upload part request.</p> <p>Part numbers can be any number from 1 to 10,000, inclusive. A part number uniquely identifies a part and also defines its position within the object being created. If you upload a new part using the same part number that was used with a previous part, the previously uploaded part is overwritten. Each part must be at least 5 MB in size, except the last part. There is no size limit on the last part of your multipart upload.</p> <p>To ensure that data is not corrupted when traversing the network, specify the `Content-MD5` header in the upload part request. IONOS Object Storage checks the part data against the provided MD5 value. If they do not match, IONOS Object Storage returns an error. </p> <p>If the upload request is signed with Signature Version 4, then IONOS Object Storage uses the `x-amz-content-sha256` header as a checksum instead of `Content-MD5`. </p> <p> <b>Note:</b> After you initiate multipart upload and upload one or more parts, you must either complete or abort multipart upload in order to stop getting charged for storage of the uploaded parts. Only after you either complete or abort multipart upload, IONOS Object Storage frees up the parts storage and stops charging you for the parts storage.</p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param bucket
	@param key Object key for which the multipart upload was initiated.
	@return ApiUploadPartRequest
*/
func (a *UploadsApiService) UploadPart(ctx context.Context, bucket string, key string) ApiUploadPartRequest {
	return ApiUploadPartRequest{
		ApiService: a,
		ctx:        ctx,
		bucket:     bucket,
		key:        key,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *UploadsApiService) UploadPartExecute(r ApiUploadPartRequest) (map[string]interface{}, *APIResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UploadsApiService.UploadPart")
	if err != nil {
		gerr := GenericOpenAPIError{}
		gerr.SetError(err.Error())
		return localVarReturnValue, nil, gerr
	}

	localVarPath := localBasePath + "/{Bucket}/{Key}?uploadId"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", parameterValueToString(r.bucket, "bucket"), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Key"+"}", parameterValueToString(r.key, "key"), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if Strlen(r.bucket) < 3 {
		return localVarReturnValue, nil, reportError("bucket must have at least 3 elements")
	}
	if Strlen(r.bucket) > 63 {
		return localVarReturnValue, nil, reportError("bucket must have less than 63 elements")
	}
	if Strlen(r.key) < 1 {
		return localVarReturnValue, nil, reportError("key must have at least 1 elements")
	}
	if r.partNumber == nil {
		return localVarReturnValue, nil, reportError("partNumber is required and must be specified")
	}
	if r.uploadId == nil {
		return localVarReturnValue, nil, reportError("uploadId is required and must be specified")
	}
	if r.uploadPartRequest == nil {
		return localVarReturnValue, nil, reportError("uploadPartRequest is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "partNumber", r.partNumber, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "uploadId", r.uploadId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.contentLength != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Length", r.contentLength, "")
	}
	if r.contentMD5 != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-MD5", r.contentMD5, "")
	}
	if r.xAmzServerSideEncryptionCustomerAlgorithm != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-customer-algorithm", r.xAmzServerSideEncryptionCustomerAlgorithm, "")
	}
	if r.xAmzServerSideEncryptionCustomerKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-customer-key", r.xAmzServerSideEncryptionCustomerKey, "")
	}
	if r.xAmzServerSideEncryptionCustomerKeyMD5 != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-customer-key-MD5", r.xAmzServerSideEncryptionCustomerKeyMD5, "")
	}
	// body params
	localVarPostBody = r.uploadPartRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, httpRequestTime, err := a.client.callAPI(req)
	localVarAPIResponse := &APIResponse{
		Response:    localVarHTTPResponse,
		Method:      localVarHTTPMethod,
		RequestTime: httpRequestTime,
		RequestURL:  localVarPath,
		Operation:   "UploadPart",
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{}
		newErr.SetStatusCode(localVarHTTPResponse.StatusCode)
		newErr.SetBody(localVarBody)
		newErr.SetError(fmt.Sprintf("%s: %s", localVarHTTPResponse.Status, string(localVarBody)))
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{}
		newErr.SetStatusCode(localVarHTTPResponse.StatusCode)
		newErr.SetBody(localVarBody)
		newErr.SetError(err.Error())
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}

type ApiUploadPartCopyRequest struct {
	ctx                                       context.Context
	ApiService                                *UploadsApiService
	bucket                                    string
	xAmzCopySource                            *string
	key                                       string
	partNumber                                *int32
	uploadId                                  *string
	xAmzCopySourceIfMatch                     *string
	xAmzCopySourceIfModifiedSince             *time.Time
	xAmzCopySourceIfNoneMatch                 *string
	xAmzCopySourceIfUnmodifiedSince           *time.Time
	xAmzCopySourceRange                       *string
	xAmzServerSideEncryptionCustomerAlgorithm *string
}

// &lt;p&gt;Specifies the source object for the copy operation. &lt;/p&gt;
func (r ApiUploadPartCopyRequest) XAmzCopySource(xAmzCopySource string) ApiUploadPartCopyRequest {
	r.xAmzCopySource = &xAmzCopySource
	return r
}

// Part number of part being copied. This is a positive integer between 1 and 10,000.
func (r ApiUploadPartCopyRequest) PartNumber(partNumber int32) ApiUploadPartCopyRequest {
	r.partNumber = &partNumber
	return r
}

// Upload ID identifying the multipart upload whose part is being copied.
func (r ApiUploadPartCopyRequest) UploadId(uploadId string) ApiUploadPartCopyRequest {
	r.uploadId = &uploadId
	return r
}

// Copies the object if its entity tag (ETag) matches the specified tag.
func (r ApiUploadPartCopyRequest) XAmzCopySourceIfMatch(xAmzCopySourceIfMatch string) ApiUploadPartCopyRequest {
	r.xAmzCopySourceIfMatch = &xAmzCopySourceIfMatch
	return r
}

// Copies the object if it has been modified since the specified time.
func (r ApiUploadPartCopyRequest) XAmzCopySourceIfModifiedSince(xAmzCopySourceIfModifiedSince time.Time) ApiUploadPartCopyRequest {
	r.xAmzCopySourceIfModifiedSince = &xAmzCopySourceIfModifiedSince
	return r
}

// Copies the object if its entity tag (ETag) is different than the specified ETag.
func (r ApiUploadPartCopyRequest) XAmzCopySourceIfNoneMatch(xAmzCopySourceIfNoneMatch string) ApiUploadPartCopyRequest {
	r.xAmzCopySourceIfNoneMatch = &xAmzCopySourceIfNoneMatch
	return r
}

// Copies the object if it hasn&#39;t been modified since the specified time.
func (r ApiUploadPartCopyRequest) XAmzCopySourceIfUnmodifiedSince(xAmzCopySourceIfUnmodifiedSince time.Time) ApiUploadPartCopyRequest {
	r.xAmzCopySourceIfUnmodifiedSince = &xAmzCopySourceIfUnmodifiedSince
	return r
}

// The range of bytes to copy from the source object. The range value must use the form bytes&#x3D;first-last, where the first and last are the zero-based byte offsets to copy. For example, bytes&#x3D;0-9 indicates that you want to copy the first 10 bytes of the source. You can copy a range only if the source object is greater than 5 MB.
func (r ApiUploadPartCopyRequest) XAmzCopySourceRange(xAmzCopySourceRange string) ApiUploadPartCopyRequest {
	r.xAmzCopySourceRange = &xAmzCopySourceRange
	return r
}

// Specifies the algorithm to use to when encrypting the object (AES256).
func (r ApiUploadPartCopyRequest) XAmzServerSideEncryptionCustomerAlgorithm(xAmzServerSideEncryptionCustomerAlgorithm string) ApiUploadPartCopyRequest {
	r.xAmzServerSideEncryptionCustomerAlgorithm = &xAmzServerSideEncryptionCustomerAlgorithm
	return r
}

func (r ApiUploadPartCopyRequest) Execute() (*UploadPartCopyOutput, *APIResponse, error) {
	return r.ApiService.UploadPartCopyExecute(r)
}

/*
UploadPartCopy UploadPartCopy

<p>Uploads a part by copying data from an existing object as data source. You specify the data source by adding the request header `x-amz-copy-source` in your request and a byte range by adding the request header `x-amz-copy-source-range` in your request. </p> <p>The minimum allowable part size for a multipart upload is 5 MB.</p> <note> <p>Instead of using an existing object as part data, you might use the `UploadPart` operation and provide data in your request.</p> </note> <p>You must initiate a multipart upload before you can upload any part. In response to your initiate request. IONOS Object Storage returns a unique identifier, the upload ID, that you must include in your upload part request.</p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param bucket
	@param key Object key for which the multipart upload was initiated.
	@return ApiUploadPartCopyRequest
*/
func (a *UploadsApiService) UploadPartCopy(ctx context.Context, bucket string, key string) ApiUploadPartCopyRequest {
	return ApiUploadPartCopyRequest{
		ApiService: a,
		ctx:        ctx,
		bucket:     bucket,
		key:        key,
	}
}

// Execute executes the request
//
//	@return UploadPartCopyOutput
func (a *UploadsApiService) UploadPartCopyExecute(r ApiUploadPartCopyRequest) (*UploadPartCopyOutput, *APIResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UploadPartCopyOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UploadsApiService.UploadPartCopy")
	if err != nil {
		gerr := GenericOpenAPIError{}
		gerr.SetError(err.Error())
		return localVarReturnValue, nil, gerr
	}

	localVarPath := localBasePath + "/{Bucket}/{Key}?x-amz-copy-source&partNumber&uploadId"
	localVarPath = strings.Replace(localVarPath, "{"+"Bucket"+"}", parameterValueToString(r.bucket, "bucket"), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Key"+"}", parameterValueToString(r.key, "key"), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if Strlen(r.bucket) < 3 {
		return localVarReturnValue, nil, reportError("bucket must have at least 3 elements")
	}
	if Strlen(r.bucket) > 63 {
		return localVarReturnValue, nil, reportError("bucket must have less than 63 elements")
	}
	if r.xAmzCopySource == nil {
		return localVarReturnValue, nil, reportError("xAmzCopySource is required and must be specified")
	}
	if Strlen(r.key) < 1 {
		return localVarReturnValue, nil, reportError("key must have at least 1 elements")
	}
	if r.partNumber == nil {
		return localVarReturnValue, nil, reportError("partNumber is required and must be specified")
	}
	if r.uploadId == nil {
		return localVarReturnValue, nil, reportError("uploadId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "partNumber", r.partNumber, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "uploadId", r.uploadId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-copy-source", r.xAmzCopySource, "")
	if r.xAmzCopySourceIfMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-copy-source-if-match", r.xAmzCopySourceIfMatch, "")
	}
	if r.xAmzCopySourceIfModifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-copy-source-if-modified-since", r.xAmzCopySourceIfModifiedSince, "")
	}
	if r.xAmzCopySourceIfNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-copy-source-if-none-match", r.xAmzCopySourceIfNoneMatch, "")
	}
	if r.xAmzCopySourceIfUnmodifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-copy-source-if-unmodified-since", r.xAmzCopySourceIfUnmodifiedSince, "")
	}
	if r.xAmzCopySourceRange != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-copy-source-range", r.xAmzCopySourceRange, "")
	}
	if r.xAmzServerSideEncryptionCustomerAlgorithm != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-amz-server-side-encryption-customer-algorithm", r.xAmzServerSideEncryptionCustomerAlgorithm, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hmac"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, httpRequestTime, err := a.client.callAPI(req)
	localVarAPIResponse := &APIResponse{
		Response:    localVarHTTPResponse,
		Method:      localVarHTTPMethod,
		RequestTime: httpRequestTime,
		RequestURL:  localVarPath,
		Operation:   "UploadPartCopy",
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarAPIResponse.Payload = localVarBody
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarAPIResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{}
		newErr.SetStatusCode(localVarHTTPResponse.StatusCode)
		newErr.SetBody(localVarBody)
		newErr.SetError(fmt.Sprintf("%s: %s", localVarHTTPResponse.Status, string(localVarBody)))
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{}
		newErr.SetStatusCode(localVarHTTPResponse.StatusCode)
		newErr.SetBody(localVarBody)
		newErr.SetError(err.Error())
		return localVarReturnValue, localVarAPIResponse, newErr
	}

	return localVarReturnValue, localVarAPIResponse, nil
}
